#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Dec 13 16:16:53 2021 by generateDS.py version 2.40.6.
# Python 3.9.7 (default, Sep 16 2021, 13:09:58)  [GCC 7.5.0]
#
# Command line options:
#   ('-o', 'opendrive_parser_14H.py')
#
# Command line arguments:
#   OpenDRIVE_1.4H.xsd
#
# Command line:
#   /home/SENSETIME/jianxinyu/anaconda3/envs/neuralsim/bin/generateDS.py -o "opendrive_parser_14H.py" OpenDRIVE_1.4H.xsd
#
# Current working directory (os.getcwd()):
#   OpendriveParser
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': None,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    setattr(settings[n], self[n])
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % float(input_data)).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class access(str, Enum):
    ALL='all'
    CAR='car'
    WOMEN='women'
    HANDICAPPED='handicapped'
    BUS='bus'
    TRUCK='truck'
    ELECTRIC='electric'
    RESIDENTS='residents'


class bridgeType(str, Enum):
    CONCRETE='concrete'
    STEEL='steel'
    BRICK='brick'
    WOOD='wood'


class color(str, Enum):
    STANDARD='standard'
    BLUE='blue'
    GREEN='green'
    RED='red'
    WHITE='white'
    YELLOW='yellow'


class contactPoint(str, Enum):
    START='start'
    END='end'


class crossfallSide(str, Enum):
    LEFT='left'
    RIGHT='right'
    BOTH='both'


class dir(str, Enum):
    _='+'
    __1='-'


class direction(str, Enum):
    SAME='same'
    OPPOSITE='opposite'


class dynamic(str, Enum):
    YES='yes'
    NO='no'


class elementType(str, Enum):
    ROAD='road'
    JUNCTION='junction'


class junctionGroupType(str, Enum):
    ROUNDABOUT='roundabout'
    UNKNOWN='unknown'


class laneChange(str, Enum):
    INCREASE='increase'
    DECREASE='decrease'
    BOTH='both'
    NONE='none'


class laneType(str, Enum):
    NONE='none'
    DRIVING='driving'
    STOP='stop'
    SHOULDER='shoulder'
    BIKING='biking'
    SIDEWALK='sidewalk'
    BORDER='border'
    RESTRICTED='restricted'
    PARKING='parking'
    BIDIRECTIONAL='bidirectional'
    MEDIAN='median'
    SPECIAL_1='special1'
    SPECIAL_2='special2'
    SPECIAL_3='special3'
    ROAD_WORKS='roadWorks'
    TRAM='tram'
    RAIL='rail'
    ENTRY='entry'
    EXIT='exit'
    OFF_RAMP='offRamp'
    ON_RAMP='onRamp'


class max(str, Enum):
    NOLIMIT='no limit'
    UNDEFINED='undefined'


class mode(str, Enum):
    ATTACHED='attached'
    ATTACHED_0='attached0'
    GENUINE='genuine'


class orientation(str, Enum):
    _='+'
    __1='-'
    NONE='none'


class pRange(str, Enum):
    ARC_LENGTH='arcLength'
    NORMALIZED='normalized'


class parkingSpacemarkingSide(str, Enum):
    FRONT='front'
    REAR='rear'
    LEFT='left'
    RIGHT='right'


class position(str, Enum):
    DYNAMIC='dynamic'
    STRAIGHT='straight'
    TURN='turn'


class purpose(str, Enum):
    ELEVATION='elevation'
    FRICTION='friction'


class restriction(str, Enum):
    SIMULATOR='simulator'
    AUTONOMOUSTRAFFIC='autonomous traffic'
    PEDESTRIAN='pedestrian'
    NONE='none'


class roadType(str, Enum):
    UNKNOWN='unknown'
    RURAL='rural'
    MOTORWAY='motorway'
    TOWN='town'
    LOW_SPEED='lowSpeed'
    PEDESTRIAN='pedestrian'
    BICYCLE='bicycle'


class roadmarkType(str, Enum):
    NONE='none'
    SOLID='solid'
    BROKEN='broken'
    SOLIDSOLID='solid solid'
    SOLIDBROKEN='solid broken'
    BROKENSOLID='broken solid'
    BROKENBROKEN='broken broken'
    BOTTSDOTS='botts dots'
    GRASS='grass'
    CURB='curb'


class rule(str, Enum):
    NOPASSING='no passing'
    CAUTION='caution'
    NONE='none'


class side(str, Enum):
    LEFT='left'
    RIGHT='right'


class singleSide(str, Enum):
    TRUE='true'
    FALSE='false'


class stationType(str, Enum):
    SMALL='small'
    MEDIUM='medium'
    LARGE='large'


class surfaceOrientation(str, Enum):
    SAME='same'
    OPPOSITE='opposite'


class tunnelType(str, Enum):
    STANDARD='standard'
    UNDERPASS='underpass'


class unit(str, Enum):
    M='m'
    KM='km'
    FT='ft'
    MILE='mile'
    MS='m/s'
    MPH='mph'
    KMH='km/h'
    KG='kg'
    T='t'
    _='%'


class weight(str, Enum):
    STANDARD='standard'
    BOLD='bold'


class OpenDRIVE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, header=None, road=None, controller=None, junction=None, junctionGroup=None, station=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.header = header
        self.header_nsprefix_ = None
        if road is None:
            self.road = []
        else:
            self.road = road
        self.road_nsprefix_ = None
        if controller is None:
            self.controller = []
        else:
            self.controller = controller
        self.controller_nsprefix_ = None
        if junction is None:
            self.junction = []
        else:
            self.junction = junction
        self.junction_nsprefix_ = None
        if junctionGroup is None:
            self.junctionGroup = []
        else:
            self.junctionGroup = junctionGroup
        self.junctionGroup_nsprefix_ = None
        if station is None:
            self.station = []
        else:
            self.station = station
        self.station_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenDRIVE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenDRIVE.subclass:
            return OpenDRIVE.subclass(*args_, **kwargs_)
        else:
            return OpenDRIVE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_header(self):
        return self.header
    def set_header(self, header):
        self.header = header
    def get_road(self):
        return self.road
    def set_road(self, road):
        self.road = road
    def add_road(self, value):
        self.road.append(value)
    def insert_road_at(self, index, value):
        self.road.insert(index, value)
    def replace_road_at(self, index, value):
        self.road[index] = value
    def get_controller(self):
        return self.controller
    def set_controller(self, controller):
        self.controller = controller
    def add_controller(self, value):
        self.controller.append(value)
    def insert_controller_at(self, index, value):
        self.controller.insert(index, value)
    def replace_controller_at(self, index, value):
        self.controller[index] = value
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def add_junction(self, value):
        self.junction.append(value)
    def insert_junction_at(self, index, value):
        self.junction.insert(index, value)
    def replace_junction_at(self, index, value):
        self.junction[index] = value
    def get_junctionGroup(self):
        return self.junctionGroup
    def set_junctionGroup(self, junctionGroup):
        self.junctionGroup = junctionGroup
    def add_junctionGroup(self, value):
        self.junctionGroup.append(value)
    def insert_junctionGroup_at(self, index, value):
        self.junctionGroup.insert(index, value)
    def replace_junctionGroup_at(self, index, value):
        self.junctionGroup[index] = value
    def get_station(self):
        return self.station
    def set_station(self, station):
        self.station = station
    def add_station(self, value):
        self.station.append(value)
    def insert_station_at(self, index, value):
        self.station.insert(index, value)
    def replace_station_at(self, index, value):
        self.station[index] = value
    def _hasContent(self):
        if (
            self.header is not None or
            self.road or
            self.controller or
            self.junction or
            self.junctionGroup or
            self.station
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenDRIVE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OpenDRIVE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OpenDRIVE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OpenDRIVE')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OpenDRIVE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OpenDRIVE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenDRIVE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            namespaceprefix_ = self.header_nsprefix_ + ':' if (UseCapturedNS_ and self.header_nsprefix_) else ''
            self.header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='header', pretty_print=pretty_print)
        for road_ in self.road:
            namespaceprefix_ = self.road_nsprefix_ + ':' if (UseCapturedNS_ and self.road_nsprefix_) else ''
            road_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='road', pretty_print=pretty_print)
        for controller_ in self.controller:
            namespaceprefix_ = self.controller_nsprefix_ + ':' if (UseCapturedNS_ and self.controller_nsprefix_) else ''
            controller_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controller', pretty_print=pretty_print)
        for junction_ in self.junction:
            namespaceprefix_ = self.junction_nsprefix_ + ':' if (UseCapturedNS_ and self.junction_nsprefix_) else ''
            junction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junction', pretty_print=pretty_print)
        for junctionGroup_ in self.junctionGroup:
            namespaceprefix_ = self.junctionGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.junctionGroup_nsprefix_) else ''
            junctionGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junctionGroup', pretty_print=pretty_print)
        for station_ in self.station:
            namespaceprefix_ = self.station_nsprefix_ + ':' if (UseCapturedNS_ and self.station_nsprefix_) else ''
            station_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='station', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            obj_ = headerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'road':
            obj_ = roadType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.road.append(obj_)
            obj_.original_tagname_ = 'road'
        elif nodeName_ == 'controller':
            obj_ = controllerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controller.append(obj_)
            obj_.original_tagname_ = 'controller'
        elif nodeName_ == 'junction':
            obj_ = junctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.junction.append(obj_)
            obj_.original_tagname_ = 'junction'
        elif nodeName_ == 'junctionGroup':
            obj_ = junctionGroupType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.junctionGroup.append(obj_)
            obj_.original_tagname_ = 'junctionGroup'
        elif nodeName_ == 'station':
            obj_ = stationType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.station.append(obj_)
            obj_.original_tagname_ = 'station'
# end class OpenDRIVE


class userData(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code=None, value=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userData.subclass:
            return userData.subclass(*args_, **kwargs_)
        else:
            return userData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='userData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('userData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'userData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='userData')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='userData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='userData'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='userData', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(obj_)
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class userData


class include(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, file=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, include)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if include.subclass:
            return include.subclass(*args_, **kwargs_)
        else:
            return include(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='include', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('include')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'include':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='include')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='include', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='include'):
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='include', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class include


class laneValidity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fromLane=None, toLane=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fromLane = _cast(int, fromLane)
        self.fromLane_nsprefix_ = None
        self.toLane = _cast(int, toLane)
        self.toLane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, laneValidity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if laneValidity.subclass:
            return laneValidity.subclass(*args_, **kwargs_)
        else:
            return laneValidity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_fromLane(self):
        return self.fromLane
    def set_fromLane(self, fromLane):
        self.fromLane = fromLane
    def get_toLane(self):
        return self.toLane
    def set_toLane(self, toLane):
        self.toLane = toLane
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneValidity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('laneValidity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'laneValidity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='laneValidity')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='laneValidity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='laneValidity'):
        if self.fromLane is not None and 'fromLane' not in already_processed:
            already_processed.add('fromLane')
            outfile.write(' fromLane="%s"' % self.gds_format_integer(self.fromLane, input_name='fromLane'))
        if self.toLane is not None and 'toLane' not in already_processed:
            already_processed.add('toLane')
            outfile.write(' toLane="%s"' % self.gds_format_integer(self.toLane, input_name='toLane'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneValidity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fromLane', node)
        if value is not None and 'fromLane' not in already_processed:
            already_processed.add('fromLane')
            self.fromLane = self.gds_parse_integer(value, node, 'fromLane')
        value = find_attr_value_('toLane', node)
        if value is not None and 'toLane' not in already_processed:
            already_processed.add('toLane')
            self.toLane = self.gds_parse_integer(value, node, 'toLane')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class laneValidity


class parkingSpace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, access=None, restrictions=None, marking=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.access = _cast(None, access)
        self.access_nsprefix_ = None
        self.restrictions = _cast(None, restrictions)
        self.restrictions_nsprefix_ = None
        if marking is None:
            self.marking = []
        else:
            self.marking = marking
        self.marking_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parkingSpace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parkingSpace.subclass:
            return parkingSpace.subclass(*args_, **kwargs_)
        else:
            return parkingSpace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_marking(self):
        return self.marking
    def set_marking(self, marking):
        self.marking = marking
    def add_marking(self, value):
        self.marking.append(value)
    def insert_marking_at(self, index, value):
        self.marking.insert(index, value)
    def replace_marking_at(self, index, value):
        self.marking[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_restrictions(self):
        return self.restrictions
    def set_restrictions(self, restrictions):
        self.restrictions = restrictions
    def validate_access(self, value):
        # Validate type access, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['all', 'car', 'women', 'handicapped', 'bus', 'truck', 'electric', 'residents']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on access' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.marking or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='parkingSpace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parkingSpace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parkingSpace':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parkingSpace')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parkingSpace', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parkingSpace'):
        if self.access is not None and 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.access), input_name='access')), ))
        if self.restrictions is not None and 'restrictions' not in already_processed:
            already_processed.add('restrictions')
            outfile.write(' restrictions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restrictions), input_name='restrictions')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='parkingSpace', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for marking_ in self.marking:
            namespaceprefix_ = self.marking_nsprefix_ + ':' if (UseCapturedNS_ and self.marking_nsprefix_) else ''
            marking_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='marking', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
            self.validate_access(self.access)    # validate type access
        value = find_attr_value_('restrictions', node)
        if value is not None and 'restrictions' not in already_processed:
            already_processed.add('restrictions')
            self.restrictions = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'marking':
            obj_ = markingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.marking.append(obj_)
            obj_.original_tagname_ = 'marking'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class parkingSpace


class lane(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, level=None, link=None, width=None, border=None, roadMark=None, material=None, visibility=None, speed=None, access=None, height=None, rule=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if width is None:
            self.width = []
        else:
            self.width = width
        self.width_nsprefix_ = None
        if border is None:
            self.border = []
        else:
            self.border = border
        self.border_nsprefix_ = None
        if roadMark is None:
            self.roadMark = []
        else:
            self.roadMark = roadMark
        self.roadMark_nsprefix_ = None
        if material is None:
            self.material = []
        else:
            self.material = material
        self.material_nsprefix_ = None
        if visibility is None:
            self.visibility = []
        else:
            self.visibility = visibility
        self.visibility_nsprefix_ = None
        if speed is None:
            self.speed = []
        else:
            self.speed = speed
        self.speed_nsprefix_ = None
        if access is None:
            self.access = []
        else:
            self.access = access
        self.access_nsprefix_ = None
        if height is None:
            self.height = []
        else:
            self.height = height
        self.height_nsprefix_ = None
        if rule is None:
            self.rule = []
        else:
            self.rule = rule
        self.rule_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lane.subclass:
            return lane.subclass(*args_, **kwargs_)
        else:
            return lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def add_width(self, value):
        self.width.append(value)
    def insert_width_at(self, index, value):
        self.width.insert(index, value)
    def replace_width_at(self, index, value):
        self.width[index] = value
    def get_border(self):
        return self.border
    def set_border(self, border):
        self.border = border
    def add_border(self, value):
        self.border.append(value)
    def insert_border_at(self, index, value):
        self.border.insert(index, value)
    def replace_border_at(self, index, value):
        self.border[index] = value
    def get_roadMark(self):
        return self.roadMark
    def set_roadMark(self, roadMark):
        self.roadMark = roadMark
    def add_roadMark(self, value):
        self.roadMark.append(value)
    def insert_roadMark_at(self, index, value):
        self.roadMark.insert(index, value)
    def replace_roadMark_at(self, index, value):
        self.roadMark[index] = value
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def add_material(self, value):
        self.material.append(value)
    def insert_material_at(self, index, value):
        self.material.insert(index, value)
    def replace_material_at(self, index, value):
        self.material[index] = value
    def get_visibility(self):
        return self.visibility
    def set_visibility(self, visibility):
        self.visibility = visibility
    def add_visibility(self, value):
        self.visibility.append(value)
    def insert_visibility_at(self, index, value):
        self.visibility.insert(index, value)
    def replace_visibility_at(self, index, value):
        self.visibility[index] = value
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    def add_speed(self, value):
        self.speed.append(value)
    def insert_speed_at(self, index, value):
        self.speed.insert(index, value)
    def replace_speed_at(self, index, value):
        self.speed[index] = value
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def add_access(self, value):
        self.access.append(value)
    def insert_access_at(self, index, value):
        self.access.insert(index, value)
    def replace_access_at(self, index, value):
        self.access[index] = value
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def add_height(self, value):
        self.height.append(value)
    def insert_height_at(self, index, value):
        self.height.insert(index, value)
    def replace_height_at(self, index, value):
        self.height[index] = value
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def add_rule(self, value):
        self.rule.append(value)
    def insert_rule_at(self, index, value):
        self.rule.insert(index, value)
    def replace_rule_at(self, index, value):
        self.rule[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def validate_laneType(self, value):
        # Validate type laneType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'driving', 'stop', 'shoulder', 'biking', 'sidewalk', 'border', 'restricted', 'parking', 'bidirectional', 'median', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'entry', 'exit', 'offRamp', 'onRamp']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on laneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_singleSide(self, value):
        # Validate type singleSide, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on singleSide' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.link is not None or
            self.width or
            self.border or
            self.roadMark or
            self.material or
            self.visibility or
            self.speed or
            self.access or
            self.height or
            self.rule or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lane')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lane'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lane', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for width_ in self.width:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            width_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        for border_ in self.border:
            namespaceprefix_ = self.border_nsprefix_ + ':' if (UseCapturedNS_ and self.border_nsprefix_) else ''
            border_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='border', pretty_print=pretty_print)
        for roadMark_ in self.roadMark:
            namespaceprefix_ = self.roadMark_nsprefix_ + ':' if (UseCapturedNS_ and self.roadMark_nsprefix_) else ''
            roadMark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roadMark', pretty_print=pretty_print)
        for material_ in self.material:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            material_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
        for visibility_ in self.visibility:
            namespaceprefix_ = self.visibility_nsprefix_ + ':' if (UseCapturedNS_ and self.visibility_nsprefix_) else ''
            visibility_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='visibility', pretty_print=pretty_print)
        for speed_ in self.speed:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            speed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        for access_ in self.access:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            access_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        for height_ in self.height:
            namespaceprefix_ = self.height_nsprefix_ + ':' if (UseCapturedNS_ and self.height_nsprefix_) else ''
            height_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='height', pretty_print=pretty_print)
        for rule_ in self.rule:
            namespaceprefix_ = self.rule_nsprefix_ + ':' if (UseCapturedNS_ and self.rule_nsprefix_) else ''
            rule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rule', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_laneType(self.type_)    # validate type laneType
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_singleSide(self.level)    # validate type singleSide
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'link':
            obj_ = linkType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'width':
            obj_ = widthType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width.append(obj_)
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'border':
            obj_ = borderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.border.append(obj_)
            obj_.original_tagname_ = 'border'
        elif nodeName_ == 'roadMark':
            obj_ = roadMarkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.roadMark.append(obj_)
            obj_.original_tagname_ = 'roadMark'
        elif nodeName_ == 'material':
            obj_ = materialType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'visibility':
            obj_ = visibilityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.visibility.append(obj_)
            obj_.original_tagname_ = 'visibility'
        elif nodeName_ == 'speed':
            obj_ = speedType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.speed.append(obj_)
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access.append(obj_)
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'height':
            obj_ = heightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.height.append(obj_)
            obj_.original_tagname_ = 'height'
        elif nodeName_ == 'rule':
            obj_ = ruleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rule.append(obj_)
            obj_.original_tagname_ = 'rule'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class lane


class centerLane(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, level=None, link=None, roadMark=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if roadMark is None:
            self.roadMark = []
        else:
            self.roadMark = roadMark
        self.roadMark_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, centerLane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if centerLane.subclass:
            return centerLane.subclass(*args_, **kwargs_)
        else:
            return centerLane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_roadMark(self):
        return self.roadMark
    def set_roadMark(self, roadMark):
        self.roadMark = roadMark
    def add_roadMark(self, value):
        self.roadMark.append(value)
    def insert_roadMark_at(self, index, value):
        self.roadMark.insert(index, value)
    def replace_roadMark_at(self, index, value):
        self.roadMark[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def validate_laneType(self, value):
        # Validate type laneType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'driving', 'stop', 'shoulder', 'biking', 'sidewalk', 'border', 'restricted', 'parking', 'bidirectional', 'median', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'entry', 'exit', 'offRamp', 'onRamp']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on laneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_singleSide(self, value):
        # Validate type singleSide, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on singleSide' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.link is not None or
            self.roadMark or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='centerLane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('centerLane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'centerLane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='centerLane')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='centerLane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='centerLane'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='centerLane', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for roadMark_ in self.roadMark:
            namespaceprefix_ = self.roadMark_nsprefix_ + ':' if (UseCapturedNS_ and self.roadMark_nsprefix_) else ''
            roadMark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roadMark', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_laneType(self.type_)    # validate type laneType
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_singleSide(self.level)    # validate type singleSide
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'link':
            obj_ = linkType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'roadMark':
            obj_ = roadMarkType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.roadMark.append(obj_)
            obj_.original_tagname_ = 'roadMark'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class centerLane


class headerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, revMajor=None, revMinor=None, name=None, version=None, date=None, north=None, south=None, east=None, west=None, vendor=None, geoReference=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.revMajor = _cast(int, revMajor)
        self.revMajor_nsprefix_ = None
        self.revMinor = _cast(int, revMinor)
        self.revMinor_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(float, version)
        self.version_nsprefix_ = None
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.north = _cast(float, north)
        self.north_nsprefix_ = None
        self.south = _cast(float, south)
        self.south_nsprefix_ = None
        self.east = _cast(float, east)
        self.east_nsprefix_ = None
        self.west = _cast(float, west)
        self.west_nsprefix_ = None
        self.vendor = _cast(None, vendor)
        self.vendor_nsprefix_ = None
        self.geoReference = geoReference
        self.geoReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, headerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if headerType.subclass:
            return headerType.subclass(*args_, **kwargs_)
        else:
            return headerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geoReference(self):
        return self.geoReference
    def set_geoReference(self, geoReference):
        self.geoReference = geoReference
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_revMajor(self):
        return self.revMajor
    def set_revMajor(self, revMajor):
        self.revMajor = revMajor
    def get_revMinor(self):
        return self.revMinor
    def set_revMinor(self, revMinor):
        self.revMinor = revMinor
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_north(self):
        return self.north
    def set_north(self, north):
        self.north = north
    def get_south(self):
        return self.south
    def set_south(self, south):
        self.south = south
    def get_east(self):
        return self.east
    def set_east(self, east):
        self.east = east
    def get_west(self):
        return self.west
    def set_west(self, west):
        self.west = west
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def _hasContent(self):
        if (
            self.geoReference is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='headerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('headerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'headerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='headerType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='headerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='headerType'):
        if self.revMajor is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            outfile.write(' revMajor="%s"' % self.gds_format_integer(self.revMajor, input_name='revMajor'))
        if self.revMinor is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            outfile.write(' revMinor="%s"' % self.gds_format_integer(self.revMinor, input_name='revMinor'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if self.north is not None and 'north' not in already_processed:
            already_processed.add('north')
            outfile.write(' north="%s"' % self.gds_format_double(self.north, input_name='north'))
        if self.south is not None and 'south' not in already_processed:
            already_processed.add('south')
            outfile.write(' south="%s"' % self.gds_format_double(self.south, input_name='south'))
        if self.east is not None and 'east' not in already_processed:
            already_processed.add('east')
            outfile.write(' east="%s"' % self.gds_format_double(self.east, input_name='east'))
        if self.west is not None and 'west' not in already_processed:
            already_processed.add('west')
            outfile.write(' west="%s"' % self.gds_format_double(self.west, input_name='west'))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='headerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geoReference is not None:
            namespaceprefix_ = self.geoReference_nsprefix_ + ':' if (UseCapturedNS_ and self.geoReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeoReference>%s</%sgeoReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.geoReference), input_name='geoReference')), namespaceprefix_ , eol_))
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('revMajor', node)
        if value is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            self.revMajor = self.gds_parse_integer(value, node, 'revMajor')
        value = find_attr_value_('revMinor', node)
        if value is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            self.revMinor = self.gds_parse_integer(value, node, 'revMinor')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            value = self.gds_parse_float(value, node, 'version')
            self.version = value
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('north', node)
        if value is not None and 'north' not in already_processed:
            already_processed.add('north')
            value = self.gds_parse_double(value, node, 'north')
            self.north = value
        value = find_attr_value_('south', node)
        if value is not None and 'south' not in already_processed:
            already_processed.add('south')
            value = self.gds_parse_double(value, node, 'south')
            self.south = value
        value = find_attr_value_('east', node)
        if value is not None and 'east' not in already_processed:
            already_processed.add('east')
            value = self.gds_parse_double(value, node, 'east')
            self.east = value
        value = find_attr_value_('west', node)
        if value is not None and 'west' not in already_processed:
            already_processed.add('west')
            value = self.gds_parse_double(value, node, 'west')
            self.west = value
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geoReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'geoReference')
            value_ = self.gds_validate_string(value_, node, 'geoReference')
            self.geoReference = value_
            self.geoReference_nsprefix_ = child_.prefix
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class headerType


class roadType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, length=None, id=None, junction=None, link=None, type_=None, planView=None, elevationProfile=None, lateralProfile=None, lanes=None, objects=None, signals=None, surface=None, railroad=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.junction = _cast(None, junction)
        self.junction_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        self.type__nsprefix_ = None
        self.planView = planView
        self.planView_nsprefix_ = None
        self.elevationProfile = elevationProfile
        self.elevationProfile_nsprefix_ = None
        self.lateralProfile = lateralProfile
        self.lateralProfile_nsprefix_ = None
        self.lanes = lanes
        self.lanes_nsprefix_ = None
        self.objects = objects
        self.objects_nsprefix_ = None
        self.signals = signals
        self.signals_nsprefix_ = None
        self.surface = surface
        self.surface_nsprefix_ = None
        self.railroad = railroad
        self.railroad_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, roadType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if roadType1.subclass:
            return roadType1.subclass(*args_, **kwargs_)
        else:
            return roadType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def add_type(self, value):
        self.type_.append(value)
    def insert_type_at(self, index, value):
        self.type_.insert(index, value)
    def replace_type_at(self, index, value):
        self.type_[index] = value
    def get_planView(self):
        return self.planView
    def set_planView(self, planView):
        self.planView = planView
    def get_elevationProfile(self):
        return self.elevationProfile
    def set_elevationProfile(self, elevationProfile):
        self.elevationProfile = elevationProfile
    def get_lateralProfile(self):
        return self.lateralProfile
    def set_lateralProfile(self, lateralProfile):
        self.lateralProfile = lateralProfile
    def get_lanes(self):
        return self.lanes
    def set_lanes(self, lanes):
        self.lanes = lanes
    def get_objects(self):
        return self.objects
    def set_objects(self, objects):
        self.objects = objects
    def get_signals(self):
        return self.signals
    def set_signals(self, signals):
        self.signals = signals
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_railroad(self):
        return self.railroad
    def set_railroad(self, railroad):
        self.railroad = railroad
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def _hasContent(self):
        if (
            self.link is not None or
            self.type_ or
            self.planView is not None or
            self.elevationProfile is not None or
            self.lateralProfile is not None or
            self.lanes is not None or
            self.objects is not None or
            self.signals is not None or
            self.surface is not None or
            self.railroad is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roadType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('roadType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'roadType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roadType1')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='roadType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='roadType1'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.junction is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            outfile.write(' junction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.junction), input_name='junction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roadType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for type_ in self.type_:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.planView is not None:
            namespaceprefix_ = self.planView_nsprefix_ + ':' if (UseCapturedNS_ and self.planView_nsprefix_) else ''
            self.planView.export(outfile, level, namespaceprefix_, namespacedef_='', name_='planView', pretty_print=pretty_print)
        if self.elevationProfile is not None:
            namespaceprefix_ = self.elevationProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.elevationProfile_nsprefix_) else ''
            self.elevationProfile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elevationProfile', pretty_print=pretty_print)
        if self.lateralProfile is not None:
            namespaceprefix_ = self.lateralProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.lateralProfile_nsprefix_) else ''
            self.lateralProfile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lateralProfile', pretty_print=pretty_print)
        if self.lanes is not None:
            namespaceprefix_ = self.lanes_nsprefix_ + ':' if (UseCapturedNS_ and self.lanes_nsprefix_) else ''
            self.lanes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lanes', pretty_print=pretty_print)
        if self.objects is not None:
            namespaceprefix_ = self.objects_nsprefix_ + ':' if (UseCapturedNS_ and self.objects_nsprefix_) else ''
            self.objects.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objects', pretty_print=pretty_print)
        if self.signals is not None:
            namespaceprefix_ = self.signals_nsprefix_ + ':' if (UseCapturedNS_ and self.signals_nsprefix_) else ''
            self.signals.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signals', pretty_print=pretty_print)
        if self.surface is not None:
            namespaceprefix_ = self.surface_nsprefix_ + ':' if (UseCapturedNS_ and self.surface_nsprefix_) else ''
            self.surface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surface', pretty_print=pretty_print)
        if self.railroad is not None:
            namespaceprefix_ = self.railroad_nsprefix_ + ':' if (UseCapturedNS_ and self.railroad_nsprefix_) else ''
            self.railroad.export(outfile, level, namespaceprefix_, namespacedef_='', name_='railroad', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('junction', node)
        if value is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            self.junction = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'link':
            obj_ = linkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'type':
            obj_ = typeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'planView':
            obj_ = planViewType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.planView = obj_
            obj_.original_tagname_ = 'planView'
        elif nodeName_ == 'elevationProfile':
            obj_ = elevationProfileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.elevationProfile = obj_
            obj_.original_tagname_ = 'elevationProfile'
        elif nodeName_ == 'lateralProfile':
            obj_ = lateralProfileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lateralProfile = obj_
            obj_.original_tagname_ = 'lateralProfile'
        elif nodeName_ == 'lanes':
            obj_ = lanesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lanes = obj_
            obj_.original_tagname_ = 'lanes'
        elif nodeName_ == 'objects':
            obj_ = objectsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.objects = obj_
            obj_.original_tagname_ = 'objects'
        elif nodeName_ == 'signals':
            obj_ = signalsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signals = obj_
            obj_.original_tagname_ = 'signals'
        elif nodeName_ == 'surface':
            obj_ = surfaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surface = obj_
            obj_.original_tagname_ = 'surface'
        elif nodeName_ == 'railroad':
            obj_ = railroadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.railroad = obj_
            obj_.original_tagname_ = 'railroad'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class roadType1


class linkType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, predecessor=None, successor=None, neighbor=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if neighbor is None:
            self.neighbor = []
        else:
            self.neighbor = neighbor
        self.neighbor_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkType.subclass:
            return linkType.subclass(*args_, **kwargs_)
        else:
            return linkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predecessor(self):
        return self.predecessor
    def set_predecessor(self, predecessor):
        self.predecessor = predecessor
    def get_successor(self):
        return self.successor
    def set_successor(self, successor):
        self.successor = successor
    def get_neighbor(self):
        return self.neighbor
    def set_neighbor(self, neighbor):
        self.neighbor = neighbor
    def add_neighbor(self, value):
        self.neighbor.append(value)
    def insert_neighbor_at(self, index, value):
        self.neighbor.insert(index, value)
    def replace_neighbor_at(self, index, value):
        self.neighbor[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.neighbor or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'linkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='linkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='linkType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for neighbor_ in self.neighbor:
            namespaceprefix_ = self.neighbor_nsprefix_ + ':' if (UseCapturedNS_ and self.neighbor_nsprefix_) else ''
            neighbor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='neighbor', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predecessor':
            obj_ = predecessorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = successorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'neighbor':
            obj_ = neighborType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.neighbor.append(obj_)
            obj_.original_tagname_ = 'neighbor'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class linkType


class predecessorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, elementType=None, elementId=None, contactPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, predecessorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if predecessorType.subclass:
            return predecessorType.subclass(*args_, **kwargs_)
        else:
            return predecessorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_elementType(self):
        return self.elementType
    def set_elementType(self, elementType):
        self.elementType = elementType
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_contactPoint(self):
        return self.contactPoint
    def set_contactPoint(self, contactPoint):
        self.contactPoint = contactPoint
    def validate_elementType(self, value):
        # Validate type elementType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['road', 'junction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on elementType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_contactPoint(self, value):
        # Validate type contactPoint, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on contactPoint' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='predecessorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('predecessorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'predecessorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='predecessorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='predecessorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='predecessorType'):
        if self.elementType is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
        if self.elementId is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.contactPoint is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='predecessorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
            self.validate_elementType(self.elementType)    # validate type elementType
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_contactPoint(self.contactPoint)    # validate type contactPoint
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class predecessorType


class successorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, elementType=None, elementId=None, contactPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, successorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if successorType.subclass:
            return successorType.subclass(*args_, **kwargs_)
        else:
            return successorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_elementType(self):
        return self.elementType
    def set_elementType(self, elementType):
        self.elementType = elementType
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_contactPoint(self):
        return self.contactPoint
    def set_contactPoint(self, contactPoint):
        self.contactPoint = contactPoint
    def validate_elementType(self, value):
        # Validate type elementType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['road', 'junction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on elementType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_contactPoint(self, value):
        # Validate type contactPoint, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on contactPoint' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='successorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('successorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'successorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='successorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='successorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='successorType'):
        if self.elementType is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
        if self.elementId is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.contactPoint is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='successorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
            self.validate_elementType(self.elementType)    # validate type elementType
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_contactPoint(self.contactPoint)    # validate type contactPoint
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class successorType


class neighborType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, side=None, elementId=None, direction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, neighborType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if neighborType.subclass:
            return neighborType.subclass(*args_, **kwargs_)
        else:
            return neighborType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def validate_side(self, value):
        # Validate type side, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on side' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_direction(self, value):
        # Validate type direction, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['same', 'opposite']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='neighborType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('neighborType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'neighborType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='neighborType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='neighborType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='neighborType'):
        if self.side is not None and 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if self.elementId is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='neighborType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_side(self.side)    # validate type side
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.validate_direction(self.direction)    # validate type direction
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class neighborType


class typeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, type_=None, speed=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.speed = speed
        self.speed_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeType.subclass:
            return typeType.subclass(*args_, **kwargs_)
        else:
            return typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_roadType(self, value):
        # Validate type roadType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['unknown', 'rural', 'motorway', 'town', 'lowSpeed', 'pedestrian', 'bicycle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roadType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.speed is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.speed is not None:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            self.speed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_roadType(self.type_)    # validate type roadType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'speed':
            obj_ = speedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.speed = obj_
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class typeType


class speedType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, max=None, unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.max = _cast(int, max)
        self.max_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, speedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if speedType.subclass:
            return speedType.subclass(*args_, **kwargs_)
        else:
            return speedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def validate_max(self, value):
        # Validate type max, a restriction on xsd:integer.
        pass
    def validate_unit(self, value):
        # Validate type unit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['m', 'km', 'ft', 'mile', 'm/s', 'mph', 'km/h', 'kg', 't', '%']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on unit' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='speedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('speedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'speedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='speedType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='speedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='speedType'):
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_integer(self.max, input_name='max'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='speedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            self.max = self.gds_parse_integer(value, node, 'max')
            self.validate_max(self.max)    # validate type max
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_unit(self.unit)    # validate type unit
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class speedType


class planViewType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, geometry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if geometry is None:
            self.geometry = []
        else:
            self.geometry = geometry
        self.geometry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, planViewType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if planViewType.subclass:
            return planViewType.subclass(*args_, **kwargs_)
        else:
            return planViewType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geometry(self):
        return self.geometry
    def set_geometry(self, geometry):
        self.geometry = geometry
    def add_geometry(self, value):
        self.geometry.append(value)
    def insert_geometry_at(self, index, value):
        self.geometry.insert(index, value)
    def replace_geometry_at(self, index, value):
        self.geometry[index] = value
    def _hasContent(self):
        if (
            self.geometry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='planViewType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('planViewType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'planViewType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='planViewType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='planViewType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='planViewType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='planViewType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for geometry_ in self.geometry:
            namespaceprefix_ = self.geometry_nsprefix_ + ':' if (UseCapturedNS_ and self.geometry_nsprefix_) else ''
            geometry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geometry', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geometry':
            obj_ = geometryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geometry.append(obj_)
            obj_.original_tagname_ = 'geometry'
# end class planViewType


class geometryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, x=None, y=None, hdg=None, length=None, line=None, spiral=None, arc=None, poly3=None, paramPoly3=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.line = line
        self.line_nsprefix_ = None
        self.spiral = spiral
        self.spiral_nsprefix_ = None
        self.arc = arc
        self.arc_nsprefix_ = None
        self.poly3 = poly3
        self.poly3_nsprefix_ = None
        self.paramPoly3 = paramPoly3
        self.paramPoly3_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, geometryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if geometryType.subclass:
            return geometryType.subclass(*args_, **kwargs_)
        else:
            return geometryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_spiral(self):
        return self.spiral
    def set_spiral(self, spiral):
        self.spiral = spiral
    def get_arc(self):
        return self.arc
    def set_arc(self, arc):
        self.arc = arc
    def get_poly3(self):
        return self.poly3
    def set_poly3(self, poly3):
        self.poly3 = poly3
    def get_paramPoly3(self):
        return self.paramPoly3
    def set_paramPoly3(self, paramPoly3):
        self.paramPoly3 = paramPoly3
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_hdg(self):
        return self.hdg
    def set_hdg(self, hdg):
        self.hdg = hdg
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def _hasContent(self):
        if (
            self.line is not None or
            self.spiral is not None or
            self.arc is not None or
            self.poly3 is not None or
            self.paramPoly3 is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='geometryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('geometryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'geometryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='geometryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='geometryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='geometryType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='geometryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.line is not None:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            self.line.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        if self.spiral is not None:
            namespaceprefix_ = self.spiral_nsprefix_ + ':' if (UseCapturedNS_ and self.spiral_nsprefix_) else ''
            self.spiral.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spiral', pretty_print=pretty_print)
        if self.arc is not None:
            namespaceprefix_ = self.arc_nsprefix_ + ':' if (UseCapturedNS_ and self.arc_nsprefix_) else ''
            self.arc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arc', pretty_print=pretty_print)
        if self.poly3 is not None:
            namespaceprefix_ = self.poly3_nsprefix_ + ':' if (UseCapturedNS_ and self.poly3_nsprefix_) else ''
            self.poly3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='poly3', pretty_print=pretty_print)
        if self.paramPoly3 is not None:
            namespaceprefix_ = self.paramPoly3_nsprefix_ + ':' if (UseCapturedNS_ and self.paramPoly3_nsprefix_) else ''
            self.paramPoly3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paramPoly3', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line':
            obj_ = lineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line = obj_
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'spiral':
            obj_ = spiralType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spiral = obj_
            obj_.original_tagname_ = 'spiral'
        elif nodeName_ == 'arc':
            obj_ = arcType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arc = obj_
            obj_.original_tagname_ = 'arc'
        elif nodeName_ == 'poly3':
            obj_ = poly3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.poly3 = obj_
            obj_.original_tagname_ = 'poly3'
        elif nodeName_ == 'paramPoly3':
            obj_ = paramPoly3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paramPoly3 = obj_
            obj_.original_tagname_ = 'paramPoly3'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class geometryType


class lineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lineType.subclass:
            return lineType.subclass(*args_, **kwargs_)
        else:
            return lineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lineType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lineType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class lineType


class spiralType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, curvStart=None, curvEnd=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.curvStart = _cast(float, curvStart)
        self.curvStart_nsprefix_ = None
        self.curvEnd = _cast(float, curvEnd)
        self.curvEnd_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, spiralType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if spiralType.subclass:
            return spiralType.subclass(*args_, **kwargs_)
        else:
            return spiralType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_curvStart(self):
        return self.curvStart
    def set_curvStart(self, curvStart):
        self.curvStart = curvStart
    def get_curvEnd(self):
        return self.curvEnd
    def set_curvEnd(self, curvEnd):
        self.curvEnd = curvEnd
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='spiralType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spiralType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'spiralType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spiralType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='spiralType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='spiralType'):
        if self.curvStart is not None and 'curvStart' not in already_processed:
            already_processed.add('curvStart')
            outfile.write(' curvStart="%s"' % self.gds_format_double(self.curvStart, input_name='curvStart'))
        if self.curvEnd is not None and 'curvEnd' not in already_processed:
            already_processed.add('curvEnd')
            outfile.write(' curvEnd="%s"' % self.gds_format_double(self.curvEnd, input_name='curvEnd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='spiralType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curvStart', node)
        if value is not None and 'curvStart' not in already_processed:
            already_processed.add('curvStart')
            value = self.gds_parse_double(value, node, 'curvStart')
            self.curvStart = value
        value = find_attr_value_('curvEnd', node)
        if value is not None and 'curvEnd' not in already_processed:
            already_processed.add('curvEnd')
            value = self.gds_parse_double(value, node, 'curvEnd')
            self.curvEnd = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class spiralType


class arcType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, curvature=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.curvature = _cast(float, curvature)
        self.curvature_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arcType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arcType.subclass:
            return arcType.subclass(*args_, **kwargs_)
        else:
            return arcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_curvature(self):
        return self.curvature
    def set_curvature(self, curvature):
        self.curvature = curvature
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arcType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arcType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'arcType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arcType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='arcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='arcType'):
        if self.curvature is not None and 'curvature' not in already_processed:
            already_processed.add('curvature')
            outfile.write(' curvature="%s"' % self.gds_format_double(self.curvature, input_name='curvature'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curvature', node)
        if value is not None and 'curvature' not in already_processed:
            already_processed.add('curvature')
            value = self.gds_parse_double(value, node, 'curvature')
            self.curvature = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class arcType


class poly3Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, poly3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if poly3Type.subclass:
            return poly3Type.subclass(*args_, **kwargs_)
        else:
            return poly3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='poly3Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('poly3Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'poly3Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='poly3Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='poly3Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='poly3Type'):
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='poly3Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class poly3Type


class paramPoly3Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, aU=None, bU=None, cU=None, dU=None, aV=None, bV=None, cV=None, dV=None, pRange=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.aU = _cast(float, aU)
        self.aU_nsprefix_ = None
        self.bU = _cast(float, bU)
        self.bU_nsprefix_ = None
        self.cU = _cast(float, cU)
        self.cU_nsprefix_ = None
        self.dU = _cast(float, dU)
        self.dU_nsprefix_ = None
        self.aV = _cast(float, aV)
        self.aV_nsprefix_ = None
        self.bV = _cast(float, bV)
        self.bV_nsprefix_ = None
        self.cV = _cast(float, cV)
        self.cV_nsprefix_ = None
        self.dV = _cast(float, dV)
        self.dV_nsprefix_ = None
        self.pRange = _cast(None, pRange)
        self.pRange_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paramPoly3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paramPoly3Type.subclass:
            return paramPoly3Type.subclass(*args_, **kwargs_)
        else:
            return paramPoly3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_aU(self):
        return self.aU
    def set_aU(self, aU):
        self.aU = aU
    def get_bU(self):
        return self.bU
    def set_bU(self, bU):
        self.bU = bU
    def get_cU(self):
        return self.cU
    def set_cU(self, cU):
        self.cU = cU
    def get_dU(self):
        return self.dU
    def set_dU(self, dU):
        self.dU = dU
    def get_aV(self):
        return self.aV
    def set_aV(self, aV):
        self.aV = aV
    def get_bV(self):
        return self.bV
    def set_bV(self, bV):
        self.bV = bV
    def get_cV(self):
        return self.cV
    def set_cV(self, cV):
        self.cV = cV
    def get_dV(self):
        return self.dV
    def set_dV(self, dV):
        self.dV = dV
    def get_pRange(self):
        return self.pRange
    def set_pRange(self, pRange):
        self.pRange = pRange
    def validate_pRange(self, value):
        # Validate type pRange, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['arcLength', 'normalized']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pRange' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='paramPoly3Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paramPoly3Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'paramPoly3Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paramPoly3Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='paramPoly3Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='paramPoly3Type'):
        if self.aU is not None and 'aU' not in already_processed:
            already_processed.add('aU')
            outfile.write(' aU="%s"' % self.gds_format_double(self.aU, input_name='aU'))
        if self.bU is not None and 'bU' not in already_processed:
            already_processed.add('bU')
            outfile.write(' bU="%s"' % self.gds_format_double(self.bU, input_name='bU'))
        if self.cU is not None and 'cU' not in already_processed:
            already_processed.add('cU')
            outfile.write(' cU="%s"' % self.gds_format_double(self.cU, input_name='cU'))
        if self.dU is not None and 'dU' not in already_processed:
            already_processed.add('dU')
            outfile.write(' dU="%s"' % self.gds_format_double(self.dU, input_name='dU'))
        if self.aV is not None and 'aV' not in already_processed:
            already_processed.add('aV')
            outfile.write(' aV="%s"' % self.gds_format_double(self.aV, input_name='aV'))
        if self.bV is not None and 'bV' not in already_processed:
            already_processed.add('bV')
            outfile.write(' bV="%s"' % self.gds_format_double(self.bV, input_name='bV'))
        if self.cV is not None and 'cV' not in already_processed:
            already_processed.add('cV')
            outfile.write(' cV="%s"' % self.gds_format_double(self.cV, input_name='cV'))
        if self.dV is not None and 'dV' not in already_processed:
            already_processed.add('dV')
            outfile.write(' dV="%s"' % self.gds_format_double(self.dV, input_name='dV'))
        if self.pRange is not None and 'pRange' not in already_processed:
            already_processed.add('pRange')
            outfile.write(' pRange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pRange), input_name='pRange')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='paramPoly3Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aU', node)
        if value is not None and 'aU' not in already_processed:
            already_processed.add('aU')
            value = self.gds_parse_double(value, node, 'aU')
            self.aU = value
        value = find_attr_value_('bU', node)
        if value is not None and 'bU' not in already_processed:
            already_processed.add('bU')
            value = self.gds_parse_double(value, node, 'bU')
            self.bU = value
        value = find_attr_value_('cU', node)
        if value is not None and 'cU' not in already_processed:
            already_processed.add('cU')
            value = self.gds_parse_double(value, node, 'cU')
            self.cU = value
        value = find_attr_value_('dU', node)
        if value is not None and 'dU' not in already_processed:
            already_processed.add('dU')
            value = self.gds_parse_double(value, node, 'dU')
            self.dU = value
        value = find_attr_value_('aV', node)
        if value is not None and 'aV' not in already_processed:
            already_processed.add('aV')
            value = self.gds_parse_double(value, node, 'aV')
            self.aV = value
        value = find_attr_value_('bV', node)
        if value is not None and 'bV' not in already_processed:
            already_processed.add('bV')
            value = self.gds_parse_double(value, node, 'bV')
            self.bV = value
        value = find_attr_value_('cV', node)
        if value is not None and 'cV' not in already_processed:
            already_processed.add('cV')
            value = self.gds_parse_double(value, node, 'cV')
            self.cV = value
        value = find_attr_value_('dV', node)
        if value is not None and 'dV' not in already_processed:
            already_processed.add('dV')
            value = self.gds_parse_double(value, node, 'dV')
            self.dV = value
        value = find_attr_value_('pRange', node)
        if value is not None and 'pRange' not in already_processed:
            already_processed.add('pRange')
            self.pRange = value
            self.validate_pRange(self.pRange)    # validate type pRange
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class paramPoly3Type


class elevationProfileType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, elevation=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if elevation is None:
            self.elevation = []
        else:
            self.elevation = elevation
        self.elevation_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, elevationProfileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if elevationProfileType.subclass:
            return elevationProfileType.subclass(*args_, **kwargs_)
        else:
            return elevationProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_elevation(self):
        return self.elevation
    def set_elevation(self, elevation):
        self.elevation = elevation
    def add_elevation(self, value):
        self.elevation.append(value)
    def insert_elevation_at(self, index, value):
        self.elevation.insert(index, value)
    def replace_elevation_at(self, index, value):
        self.elevation[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.elevation or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elevationProfileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('elevationProfileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'elevationProfileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='elevationProfileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='elevationProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='elevationProfileType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elevationProfileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for elevation_ in self.elevation:
            namespaceprefix_ = self.elevation_nsprefix_ + ':' if (UseCapturedNS_ and self.elevation_nsprefix_) else ''
            elevation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elevation', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'elevation':
            obj_ = elevationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.elevation.append(obj_)
            obj_.original_tagname_ = 'elevation'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class elevationProfileType


class elevationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, elevationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if elevationType.subclass:
            return elevationType.subclass(*args_, **kwargs_)
        else:
            return elevationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elevationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('elevationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'elevationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='elevationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='elevationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='elevationType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elevationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class elevationType


class lateralProfileType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, superelevation=None, crossfall=None, shape=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if superelevation is None:
            self.superelevation = []
        else:
            self.superelevation = superelevation
        self.superelevation_nsprefix_ = None
        if crossfall is None:
            self.crossfall = []
        else:
            self.crossfall = crossfall
        self.crossfall_nsprefix_ = None
        if shape is None:
            self.shape = []
        else:
            self.shape = shape
        self.shape_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lateralProfileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lateralProfileType.subclass:
            return lateralProfileType.subclass(*args_, **kwargs_)
        else:
            return lateralProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_superelevation(self):
        return self.superelevation
    def set_superelevation(self, superelevation):
        self.superelevation = superelevation
    def add_superelevation(self, value):
        self.superelevation.append(value)
    def insert_superelevation_at(self, index, value):
        self.superelevation.insert(index, value)
    def replace_superelevation_at(self, index, value):
        self.superelevation[index] = value
    def get_crossfall(self):
        return self.crossfall
    def set_crossfall(self, crossfall):
        self.crossfall = crossfall
    def add_crossfall(self, value):
        self.crossfall.append(value)
    def insert_crossfall_at(self, index, value):
        self.crossfall.insert(index, value)
    def replace_crossfall_at(self, index, value):
        self.crossfall[index] = value
    def get_shape(self):
        return self.shape
    def set_shape(self, shape):
        self.shape = shape
    def add_shape(self, value):
        self.shape.append(value)
    def insert_shape_at(self, index, value):
        self.shape.insert(index, value)
    def replace_shape_at(self, index, value):
        self.shape[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.superelevation or
            self.crossfall or
            self.shape or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lateralProfileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lateralProfileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lateralProfileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lateralProfileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lateralProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lateralProfileType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lateralProfileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for superelevation_ in self.superelevation:
            namespaceprefix_ = self.superelevation_nsprefix_ + ':' if (UseCapturedNS_ and self.superelevation_nsprefix_) else ''
            superelevation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superelevation', pretty_print=pretty_print)
        for crossfall_ in self.crossfall:
            namespaceprefix_ = self.crossfall_nsprefix_ + ':' if (UseCapturedNS_ and self.crossfall_nsprefix_) else ''
            crossfall_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='crossfall', pretty_print=pretty_print)
        for shape_ in self.shape:
            namespaceprefix_ = self.shape_nsprefix_ + ':' if (UseCapturedNS_ and self.shape_nsprefix_) else ''
            shape_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shape', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'superelevation':
            obj_ = superelevationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.superelevation.append(obj_)
            obj_.original_tagname_ = 'superelevation'
        elif nodeName_ == 'crossfall':
            obj_ = crossfallType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.crossfall.append(obj_)
            obj_.original_tagname_ = 'crossfall'
        elif nodeName_ == 'shape':
            obj_ = shapeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shape.append(obj_)
            obj_.original_tagname_ = 'shape'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class lateralProfileType


class superelevationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, superelevationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if superelevationType.subclass:
            return superelevationType.subclass(*args_, **kwargs_)
        else:
            return superelevationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='superelevationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('superelevationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'superelevationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='superelevationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='superelevationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='superelevationType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='superelevationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class superelevationType


class crossfallType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, side=None, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, crossfallType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if crossfallType.subclass:
            return crossfallType.subclass(*args_, **kwargs_)
        else:
            return crossfallType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_crossfallSide(self, value):
        # Validate type crossfallSide, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right', 'both']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on crossfallSide' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='crossfallType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('crossfallType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'crossfallType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='crossfallType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='crossfallType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='crossfallType'):
        if self.side is not None and 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='crossfallType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_crossfallSide(self.side)    # validate type crossfallSide
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class crossfallType


class shapeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, shapeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if shapeType.subclass:
            return shapeType.subclass(*args_, **kwargs_)
        else:
            return shapeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='shapeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('shapeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'shapeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='shapeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='shapeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='shapeType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='shapeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class shapeType


class lanesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, laneOffset=None, laneSection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if laneOffset is None:
            self.laneOffset = []
        else:
            self.laneOffset = laneOffset
        self.laneOffset_nsprefix_ = None
        if laneSection is None:
            self.laneSection = []
        else:
            self.laneSection = laneSection
        self.laneSection_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lanesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lanesType.subclass:
            return lanesType.subclass(*args_, **kwargs_)
        else:
            return lanesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_laneOffset(self):
        return self.laneOffset
    def set_laneOffset(self, laneOffset):
        self.laneOffset = laneOffset
    def add_laneOffset(self, value):
        self.laneOffset.append(value)
    def insert_laneOffset_at(self, index, value):
        self.laneOffset.insert(index, value)
    def replace_laneOffset_at(self, index, value):
        self.laneOffset[index] = value
    def get_laneSection(self):
        return self.laneSection
    def set_laneSection(self, laneSection):
        self.laneSection = laneSection
    def add_laneSection(self, value):
        self.laneSection.append(value)
    def insert_laneSection_at(self, index, value):
        self.laneSection.insert(index, value)
    def replace_laneSection_at(self, index, value):
        self.laneSection[index] = value
    def _hasContent(self):
        if (
            self.laneOffset or
            self.laneSection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lanesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lanesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lanesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lanesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lanesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lanesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lanesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for laneOffset_ in self.laneOffset:
            namespaceprefix_ = self.laneOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.laneOffset_nsprefix_) else ''
            laneOffset_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneOffset', pretty_print=pretty_print)
        for laneSection_ in self.laneSection:
            namespaceprefix_ = self.laneSection_nsprefix_ + ':' if (UseCapturedNS_ and self.laneSection_nsprefix_) else ''
            laneSection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneSection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'laneOffset':
            obj_ = laneOffsetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laneOffset.append(obj_)
            obj_.original_tagname_ = 'laneOffset'
        elif nodeName_ == 'laneSection':
            obj_ = laneSectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laneSection.append(obj_)
            obj_.original_tagname_ = 'laneSection'
# end class lanesType


class laneOffsetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, laneOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if laneOffsetType.subclass:
            return laneOffsetType.subclass(*args_, **kwargs_)
        else:
            return laneOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneOffsetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('laneOffsetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'laneOffsetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='laneOffsetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='laneOffsetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='laneOffsetType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneOffsetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class laneOffsetType


class laneSectionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, singleSide=None, left=None, center=None, right=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.singleSide = _cast(None, singleSide)
        self.singleSide_nsprefix_ = None
        self.left = left
        self.left_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.right = right
        self.right_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, laneSectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if laneSectionType.subclass:
            return laneSectionType.subclass(*args_, **kwargs_)
        else:
            return laneSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_singleSide(self):
        return self.singleSide
    def set_singleSide(self, singleSide):
        self.singleSide = singleSide
    def validate_singleSide(self, value):
        # Validate type singleSide, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on singleSide' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.left is not None or
            self.center is not None or
            self.right is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneSectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('laneSectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'laneSectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='laneSectionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='laneSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='laneSectionType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.singleSide is not None and 'singleSide' not in already_processed:
            already_processed.add('singleSide')
            outfile.write(' singleSide=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.singleSide), input_name='singleSide')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneSectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_, namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_, namespacedef_='', name_='right', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('singleSide', node)
        if value is not None and 'singleSide' not in already_processed:
            already_processed.add('singleSide')
            self.singleSide = value
            self.validate_singleSide(self.singleSide)    # validate type singleSide
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left':
            obj_ = leftType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'center':
            obj_ = centerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'right':
            obj_ = rightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class laneSectionType


class leftType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lane=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, leftType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if leftType.subclass:
            return leftType.subclass(*args_, **kwargs_)
        else:
            return leftType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lane(self):
        return self.lane
    def set_lane(self, lane):
        self.lane = lane
    def add_lane(self, value):
        self.lane.append(value)
    def insert_lane_at(self, index, value):
        self.lane.insert(index, value)
    def replace_lane_at(self, index, value):
        self.lane[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.lane or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='leftType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('leftType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'leftType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='leftType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='leftType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='leftType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='leftType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lane':
            obj_ = lane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class leftType


class centerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lane=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lane = lane
        self.lane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, centerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if centerType.subclass:
            return centerType.subclass(*args_, **kwargs_)
        else:
            return centerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lane(self):
        return self.lane
    def set_lane(self, lane):
        self.lane = lane
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.lane is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='centerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('centerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'centerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='centerType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='centerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='centerType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='centerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lane is not None:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            self.lane.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lane':
            obj_ = centerLane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lane = obj_
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class centerType


class rightType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lane=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rightType.subclass:
            return rightType.subclass(*args_, **kwargs_)
        else:
            return rightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lane(self):
        return self.lane
    def set_lane(self, lane):
        self.lane = lane
    def add_lane(self, value):
        self.lane.append(value)
    def insert_lane_at(self, index, value):
        self.lane.insert(index, value)
    def replace_lane_at(self, index, value):
        self.lane[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.lane or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rightType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rightType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rightType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lane':
            obj_ = lane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class rightType


class objectsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object=None, objectReference=None, tunnel=None, bridge=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if object is None:
            self.object = []
        else:
            self.object = object
        self.object_nsprefix_ = None
        if objectReference is None:
            self.objectReference = []
        else:
            self.objectReference = objectReference
        self.objectReference_nsprefix_ = None
        if tunnel is None:
            self.tunnel = []
        else:
            self.tunnel = tunnel
        self.tunnel_nsprefix_ = None
        if bridge is None:
            self.bridge = []
        else:
            self.bridge = bridge
        self.bridge_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectsType.subclass:
            return objectsType.subclass(*args_, **kwargs_)
        else:
            return objectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object(self):
        return self.object
    def set_object(self, object):
        self.object = object
    def add_object(self, value):
        self.object.append(value)
    def insert_object_at(self, index, value):
        self.object.insert(index, value)
    def replace_object_at(self, index, value):
        self.object[index] = value
    def get_objectReference(self):
        return self.objectReference
    def set_objectReference(self, objectReference):
        self.objectReference = objectReference
    def add_objectReference(self, value):
        self.objectReference.append(value)
    def insert_objectReference_at(self, index, value):
        self.objectReference.insert(index, value)
    def replace_objectReference_at(self, index, value):
        self.objectReference[index] = value
    def get_tunnel(self):
        return self.tunnel
    def set_tunnel(self, tunnel):
        self.tunnel = tunnel
    def add_tunnel(self, value):
        self.tunnel.append(value)
    def insert_tunnel_at(self, index, value):
        self.tunnel.insert(index, value)
    def replace_tunnel_at(self, index, value):
        self.tunnel[index] = value
    def get_bridge(self):
        return self.bridge
    def set_bridge(self, bridge):
        self.bridge = bridge
    def add_bridge(self, value):
        self.bridge.append(value)
    def insert_bridge_at(self, index, value):
        self.bridge.insert(index, value)
    def replace_bridge_at(self, index, value):
        self.bridge[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.object or
            self.objectReference or
            self.tunnel or
            self.bridge or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('objectsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'objectsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='objectsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='objectsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='objectsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.object:
            namespaceprefix_ = self.object_nsprefix_ + ':' if (UseCapturedNS_ and self.object_nsprefix_) else ''
            object_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object', pretty_print=pretty_print)
        for objectReference_ in self.objectReference:
            namespaceprefix_ = self.objectReference_nsprefix_ + ':' if (UseCapturedNS_ and self.objectReference_nsprefix_) else ''
            objectReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objectReference', pretty_print=pretty_print)
        for tunnel_ in self.tunnel:
            namespaceprefix_ = self.tunnel_nsprefix_ + ':' if (UseCapturedNS_ and self.tunnel_nsprefix_) else ''
            tunnel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tunnel', pretty_print=pretty_print)
        for bridge_ in self.bridge:
            namespaceprefix_ = self.bridge_nsprefix_ + ':' if (UseCapturedNS_ and self.bridge_nsprefix_) else ''
            bridge_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bridge', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object':
            obj_ = objectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'objectReference':
            obj_ = objectReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.objectReference.append(obj_)
            obj_.original_tagname_ = 'objectReference'
        elif nodeName_ == 'tunnel':
            obj_ = tunnelType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tunnel.append(obj_)
            obj_.original_tagname_ = 'tunnel'
        elif nodeName_ == 'bridge':
            obj_ = bridgeType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bridge.append(obj_)
            obj_.original_tagname_ = 'bridge'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class objectsType


class objectType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, id=None, s=None, t=None, zOffset=None, validLength=None, orientation=None, length=None, width=None, radius=None, height=None, hdg=None, pitch=None, roll=None, repeat=None, outline=None, material=None, validity=None, parkingSpace=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.validLength = _cast(float, validLength)
        self.validLength_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.radius = _cast(float, radius)
        self.radius_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        if repeat is None:
            self.repeat = []
        else:
            self.repeat = repeat
        self.repeat_nsprefix_ = None
        self.outline = outline
        self.outline_nsprefix_ = None
        self.material = material
        self.material_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        self.parkingSpace = parkingSpace
        self.parkingSpace_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType.subclass:
            return objectType.subclass(*args_, **kwargs_)
        else:
            return objectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_repeat(self):
        return self.repeat
    def set_repeat(self, repeat):
        self.repeat = repeat
    def add_repeat(self, value):
        self.repeat.append(value)
    def insert_repeat_at(self, index, value):
        self.repeat.insert(index, value)
    def replace_repeat_at(self, index, value):
        self.repeat[index] = value
    def get_outline(self):
        return self.outline
    def set_outline(self, outline):
        self.outline = outline
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_parkingSpace(self):
        return self.parkingSpace
    def set_parkingSpace(self, parkingSpace):
        self.parkingSpace = parkingSpace
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_validLength(self):
        return self.validLength
    def set_validLength(self, validLength):
        self.validLength = validLength
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_radius(self):
        return self.radius
    def set_radius(self, radius):
        self.radius = radius
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_hdg(self):
        return self.hdg
    def set_hdg(self, hdg):
        self.hdg = hdg
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_roll(self):
        return self.roll
    def set_roll(self, roll):
        self.roll = roll
    def validate_orientation(self, value):
        # Validate type orientation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.repeat or
            self.outline is not None or
            self.material is not None or
            self.validity or
            self.parkingSpace is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('objectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'objectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='objectType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='objectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='objectType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.validLength is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            outfile.write(' validLength="%s"' % self.gds_format_double(self.validLength, input_name='validLength'))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for repeat_ in self.repeat:
            namespaceprefix_ = self.repeat_nsprefix_ + ':' if (UseCapturedNS_ and self.repeat_nsprefix_) else ''
            repeat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeat', pretty_print=pretty_print)
        if self.outline is not None:
            namespaceprefix_ = self.outline_nsprefix_ + ':' if (UseCapturedNS_ and self.outline_nsprefix_) else ''
            self.outline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outline', pretty_print=pretty_print)
        if self.material is not None:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            self.material.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        if self.parkingSpace is not None:
            namespaceprefix_ = self.parkingSpace_nsprefix_ + ':' if (UseCapturedNS_ and self.parkingSpace_nsprefix_) else ''
            self.parkingSpace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parkingSpace', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        value = find_attr_value_('validLength', node)
        if value is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            value = self.gds_parse_double(value, node, 'validLength')
            self.validLength = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_orientation(self.orientation)    # validate type orientation
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            value = self.gds_parse_double(value, node, 'radius')
            self.radius = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            value = self.gds_parse_double(value, node, 'pitch')
            self.pitch = value
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            value = self.gds_parse_double(value, node, 'roll')
            self.roll = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'repeat':
            obj_ = repeatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeat.append(obj_)
            obj_.original_tagname_ = 'repeat'
        elif nodeName_ == 'outline':
            obj_ = outlineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.outline = obj_
            obj_.original_tagname_ = 'outline'
        elif nodeName_ == 'material':
            obj_ = materialType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.material = obj_
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'validity':
            obj_ = laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'parkingSpace':
            obj_ = parkingSpace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parkingSpace = obj_
            obj_.original_tagname_ = 'parkingSpace'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class objectType


class repeatType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, length=None, distance=None, tStart=None, tEnd=None, widthStart=None, widthEnd=None, heightStart=None, heightEnd=None, zOffsetStart=None, zOffsetEnd=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.distance = _cast(float, distance)
        self.distance_nsprefix_ = None
        self.tStart = _cast(float, tStart)
        self.tStart_nsprefix_ = None
        self.tEnd = _cast(float, tEnd)
        self.tEnd_nsprefix_ = None
        self.widthStart = _cast(float, widthStart)
        self.widthStart_nsprefix_ = None
        self.widthEnd = _cast(float, widthEnd)
        self.widthEnd_nsprefix_ = None
        self.heightStart = _cast(float, heightStart)
        self.heightStart_nsprefix_ = None
        self.heightEnd = _cast(float, heightEnd)
        self.heightEnd_nsprefix_ = None
        self.zOffsetStart = _cast(float, zOffsetStart)
        self.zOffsetStart_nsprefix_ = None
        self.zOffsetEnd = _cast(float, zOffsetEnd)
        self.zOffsetEnd_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, repeatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if repeatType.subclass:
            return repeatType.subclass(*args_, **kwargs_)
        else:
            return repeatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def get_tStart(self):
        return self.tStart
    def set_tStart(self, tStart):
        self.tStart = tStart
    def get_tEnd(self):
        return self.tEnd
    def set_tEnd(self, tEnd):
        self.tEnd = tEnd
    def get_widthStart(self):
        return self.widthStart
    def set_widthStart(self, widthStart):
        self.widthStart = widthStart
    def get_widthEnd(self):
        return self.widthEnd
    def set_widthEnd(self, widthEnd):
        self.widthEnd = widthEnd
    def get_heightStart(self):
        return self.heightStart
    def set_heightStart(self, heightStart):
        self.heightStart = heightStart
    def get_heightEnd(self):
        return self.heightEnd
    def set_heightEnd(self, heightEnd):
        self.heightEnd = heightEnd
    def get_zOffsetStart(self):
        return self.zOffsetStart
    def set_zOffsetStart(self, zOffsetStart):
        self.zOffsetStart = zOffsetStart
    def get_zOffsetEnd(self):
        return self.zOffsetEnd
    def set_zOffsetEnd(self, zOffsetEnd):
        self.zOffsetEnd = zOffsetEnd
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='repeatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('repeatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'repeatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='repeatType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='repeatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='repeatType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            outfile.write(' distance="%s"' % self.gds_format_double(self.distance, input_name='distance'))
        if self.tStart is not None and 'tStart' not in already_processed:
            already_processed.add('tStart')
            outfile.write(' tStart="%s"' % self.gds_format_double(self.tStart, input_name='tStart'))
        if self.tEnd is not None and 'tEnd' not in already_processed:
            already_processed.add('tEnd')
            outfile.write(' tEnd="%s"' % self.gds_format_double(self.tEnd, input_name='tEnd'))
        if self.widthStart is not None and 'widthStart' not in already_processed:
            already_processed.add('widthStart')
            outfile.write(' widthStart="%s"' % self.gds_format_double(self.widthStart, input_name='widthStart'))
        if self.widthEnd is not None and 'widthEnd' not in already_processed:
            already_processed.add('widthEnd')
            outfile.write(' widthEnd="%s"' % self.gds_format_double(self.widthEnd, input_name='widthEnd'))
        if self.heightStart is not None and 'heightStart' not in already_processed:
            already_processed.add('heightStart')
            outfile.write(' heightStart="%s"' % self.gds_format_double(self.heightStart, input_name='heightStart'))
        if self.heightEnd is not None and 'heightEnd' not in already_processed:
            already_processed.add('heightEnd')
            outfile.write(' heightEnd="%s"' % self.gds_format_double(self.heightEnd, input_name='heightEnd'))
        if self.zOffsetStart is not None and 'zOffsetStart' not in already_processed:
            already_processed.add('zOffsetStart')
            outfile.write(' zOffsetStart="%s"' % self.gds_format_double(self.zOffsetStart, input_name='zOffsetStart'))
        if self.zOffsetEnd is not None and 'zOffsetEnd' not in already_processed:
            already_processed.add('zOffsetEnd')
            outfile.write(' zOffsetEnd="%s"' % self.gds_format_double(self.zOffsetEnd, input_name='zOffsetEnd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='repeatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('distance', node)
        if value is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            value = self.gds_parse_double(value, node, 'distance')
            self.distance = value
        value = find_attr_value_('tStart', node)
        if value is not None and 'tStart' not in already_processed:
            already_processed.add('tStart')
            value = self.gds_parse_double(value, node, 'tStart')
            self.tStart = value
        value = find_attr_value_('tEnd', node)
        if value is not None and 'tEnd' not in already_processed:
            already_processed.add('tEnd')
            value = self.gds_parse_double(value, node, 'tEnd')
            self.tEnd = value
        value = find_attr_value_('widthStart', node)
        if value is not None and 'widthStart' not in already_processed:
            already_processed.add('widthStart')
            value = self.gds_parse_double(value, node, 'widthStart')
            self.widthStart = value
        value = find_attr_value_('widthEnd', node)
        if value is not None and 'widthEnd' not in already_processed:
            already_processed.add('widthEnd')
            value = self.gds_parse_double(value, node, 'widthEnd')
            self.widthEnd = value
        value = find_attr_value_('heightStart', node)
        if value is not None and 'heightStart' not in already_processed:
            already_processed.add('heightStart')
            value = self.gds_parse_double(value, node, 'heightStart')
            self.heightStart = value
        value = find_attr_value_('heightEnd', node)
        if value is not None and 'heightEnd' not in already_processed:
            already_processed.add('heightEnd')
            value = self.gds_parse_double(value, node, 'heightEnd')
            self.heightEnd = value
        value = find_attr_value_('zOffsetStart', node)
        if value is not None and 'zOffsetStart' not in already_processed:
            already_processed.add('zOffsetStart')
            value = self.gds_parse_double(value, node, 'zOffsetStart')
            self.zOffsetStart = value
        value = find_attr_value_('zOffsetEnd', node)
        if value is not None and 'zOffsetEnd' not in already_processed:
            already_processed.add('zOffsetEnd')
            value = self.gds_parse_double(value, node, 'zOffsetEnd')
            self.zOffsetEnd = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class repeatType


class outlineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cornerRoad=None, cornerLocal=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if cornerRoad is None:
            self.cornerRoad = []
        else:
            self.cornerRoad = cornerRoad
        self.cornerRoad_nsprefix_ = None
        if cornerLocal is None:
            self.cornerLocal = []
        else:
            self.cornerLocal = cornerLocal
        self.cornerLocal_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, outlineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if outlineType.subclass:
            return outlineType.subclass(*args_, **kwargs_)
        else:
            return outlineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cornerRoad(self):
        return self.cornerRoad
    def set_cornerRoad(self, cornerRoad):
        self.cornerRoad = cornerRoad
    def add_cornerRoad(self, value):
        self.cornerRoad.append(value)
    def insert_cornerRoad_at(self, index, value):
        self.cornerRoad.insert(index, value)
    def replace_cornerRoad_at(self, index, value):
        self.cornerRoad[index] = value
    def get_cornerLocal(self):
        return self.cornerLocal
    def set_cornerLocal(self, cornerLocal):
        self.cornerLocal = cornerLocal
    def add_cornerLocal(self, value):
        self.cornerLocal.append(value)
    def insert_cornerLocal_at(self, index, value):
        self.cornerLocal.insert(index, value)
    def replace_cornerLocal_at(self, index, value):
        self.cornerLocal[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.cornerRoad or
            self.cornerLocal or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='outlineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('outlineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'outlineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='outlineType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='outlineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='outlineType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='outlineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerRoad_ in self.cornerRoad:
            namespaceprefix_ = self.cornerRoad_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerRoad_nsprefix_) else ''
            cornerRoad_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerRoad', pretty_print=pretty_print)
        for cornerLocal_ in self.cornerLocal:
            namespaceprefix_ = self.cornerLocal_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerLocal_nsprefix_) else ''
            cornerLocal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerLocal', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cornerRoad':
            obj_ = cornerRoadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerRoad.append(obj_)
            obj_.original_tagname_ = 'cornerRoad'
        elif nodeName_ == 'cornerLocal':
            obj_ = cornerLocalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerLocal.append(obj_)
            obj_.original_tagname_ = 'cornerLocal'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class outlineType


class cornerRoadType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, dz=None, height=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.dz = _cast(float, dz)
        self.dz_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cornerRoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cornerRoadType.subclass:
            return cornerRoadType.subclass(*args_, **kwargs_)
        else:
            return cornerRoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_dz(self):
        return self.dz
    def set_dz(self, dz):
        self.dz = dz
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cornerRoadType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cornerRoadType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cornerRoadType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cornerRoadType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cornerRoadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cornerRoadType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz="%s"' % self.gds_format_double(self.dz, input_name='dz'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cornerRoadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            value = self.gds_parse_double(value, node, 'dz')
            self.dz = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class cornerRoadType


class cornerLocalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, u=None, v=None, z=None, height=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.u = _cast(float, u)
        self.u_nsprefix_ = None
        self.v = _cast(float, v)
        self.v_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cornerLocalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cornerLocalType.subclass:
            return cornerLocalType.subclass(*args_, **kwargs_)
        else:
            return cornerLocalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_u(self):
        return self.u
    def set_u(self, u):
        self.u = u
    def get_v(self):
        return self.v
    def set_v(self, v):
        self.v = v
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cornerLocalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cornerLocalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cornerLocalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cornerLocalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cornerLocalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cornerLocalType'):
        if self.u is not None and 'u' not in already_processed:
            already_processed.add('u')
            outfile.write(' u="%s"' % self.gds_format_double(self.u, input_name='u'))
        if self.v is not None and 'v' not in already_processed:
            already_processed.add('v')
            outfile.write(' v="%s"' % self.gds_format_double(self.v, input_name='v'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cornerLocalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('u', node)
        if value is not None and 'u' not in already_processed:
            already_processed.add('u')
            value = self.gds_parse_double(value, node, 'u')
            self.u = value
        value = find_attr_value_('v', node)
        if value is not None and 'v' not in already_processed:
            already_processed.add('v')
            value = self.gds_parse_double(value, node, 'v')
            self.v = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_double(value, node, 'z')
            self.z = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class cornerLocalType


class materialType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, surface=None, friction=None, roughness=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
        self.friction = _cast(float, friction)
        self.friction_nsprefix_ = None
        self.roughness = _cast(float, roughness)
        self.roughness_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, materialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if materialType.subclass:
            return materialType.subclass(*args_, **kwargs_)
        else:
            return materialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_friction(self):
        return self.friction
    def set_friction(self, friction):
        self.friction = friction
    def get_roughness(self):
        return self.roughness
    def set_roughness(self, roughness):
        self.roughness = roughness
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='materialType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('materialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'materialType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='materialType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='materialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='materialType'):
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
        if self.roughness is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            outfile.write(' roughness="%s"' % self.gds_format_double(self.roughness, input_name='roughness'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='materialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            value = self.gds_parse_double(value, node, 'friction')
            self.friction = value
        value = find_attr_value_('roughness', node)
        if value is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            value = self.gds_parse_double(value, node, 'roughness')
            self.roughness = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class materialType


class objectReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, id=None, zOffset=None, validLength=None, orientation=None, validity=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.validLength = _cast(float, validLength)
        self.validLength_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectReferenceType.subclass:
            return objectReferenceType.subclass(*args_, **kwargs_)
        else:
            return objectReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_validLength(self):
        return self.validLength
    def set_validLength(self, validLength):
        self.validLength = validLength
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def validate_orientation(self, value):
        # Validate type orientation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.validity or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('objectReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'objectReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='objectReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='objectReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='objectReferenceType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.validLength is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            outfile.write(' validLength="%s"' % self.gds_format_double(self.validLength, input_name='validLength'))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        value = find_attr_value_('validLength', node)
        if value is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            value = self.gds_parse_double(value, node, 'validLength')
            self.validLength = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_orientation(self.orientation)    # validate type orientation
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class objectReferenceType


class tunnelType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, length=None, name=None, id=None, type_=None, lighting=None, daylight=None, validity=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.lighting = _cast(float, lighting)
        self.lighting_nsprefix_ = None
        self.daylight = _cast(float, daylight)
        self.daylight_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tunnelType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tunnelType2.subclass:
            return tunnelType2.subclass(*args_, **kwargs_)
        else:
            return tunnelType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_lighting(self):
        return self.lighting
    def set_lighting(self, lighting):
        self.lighting = lighting
    def get_daylight(self):
        return self.daylight
    def set_daylight(self, daylight):
        self.daylight = daylight
    def validate_tunnelType(self, value):
        # Validate type tunnelType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'underpass']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tunnelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.validity or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tunnelType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tunnelType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tunnelType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tunnelType2')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tunnelType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tunnelType2'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.lighting is not None and 'lighting' not in already_processed:
            already_processed.add('lighting')
            outfile.write(' lighting="%s"' % self.gds_format_double(self.lighting, input_name='lighting'))
        if self.daylight is not None and 'daylight' not in already_processed:
            already_processed.add('daylight')
            outfile.write(' daylight="%s"' % self.gds_format_double(self.daylight, input_name='daylight'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tunnelType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tunnelType(self.type_)    # validate type tunnelType
        value = find_attr_value_('lighting', node)
        if value is not None and 'lighting' not in already_processed:
            already_processed.add('lighting')
            value = self.gds_parse_double(value, node, 'lighting')
            self.lighting = value
        value = find_attr_value_('daylight', node)
        if value is not None and 'daylight' not in already_processed:
            already_processed.add('daylight')
            value = self.gds_parse_double(value, node, 'daylight')
            self.daylight = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class tunnelType2


class bridgeType3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, length=None, name=None, id=None, type_=None, validity=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bridgeType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bridgeType3.subclass:
            return bridgeType3.subclass(*args_, **kwargs_)
        else:
            return bridgeType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_bridgeType(self, value):
        # Validate type bridgeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['concrete', 'steel', 'brick', 'wood']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bridgeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.validity or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bridgeType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bridgeType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bridgeType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bridgeType3')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bridgeType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bridgeType3'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bridgeType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_bridgeType(self.type_)    # validate type bridgeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class bridgeType3


class signalsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, signal=None, signalReference=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if signal is None:
            self.signal = []
        else:
            self.signal = signal
        self.signal_nsprefix_ = None
        if signalReference is None:
            self.signalReference = []
        else:
            self.signalReference = signalReference
        self.signalReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signalsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signalsType.subclass:
            return signalsType.subclass(*args_, **kwargs_)
        else:
            return signalsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_signal(self):
        return self.signal
    def set_signal(self, signal):
        self.signal = signal
    def add_signal(self, value):
        self.signal.append(value)
    def insert_signal_at(self, index, value):
        self.signal.insert(index, value)
    def replace_signal_at(self, index, value):
        self.signal[index] = value
    def get_signalReference(self):
        return self.signalReference
    def set_signalReference(self, signalReference):
        self.signalReference = signalReference
    def add_signalReference(self, value):
        self.signalReference.append(value)
    def insert_signalReference_at(self, index, value):
        self.signalReference.insert(index, value)
    def replace_signalReference_at(self, index, value):
        self.signalReference[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.signal or
            self.signalReference or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signalsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signalsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signalsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signalsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signalsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='signalsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signalsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for signal_ in self.signal:
            namespaceprefix_ = self.signal_nsprefix_ + ':' if (UseCapturedNS_ and self.signal_nsprefix_) else ''
            signal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signal', pretty_print=pretty_print)
        for signalReference_ in self.signalReference:
            namespaceprefix_ = self.signalReference_nsprefix_ + ':' if (UseCapturedNS_ and self.signalReference_nsprefix_) else ''
            signalReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signalReference', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signal':
            obj_ = signalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signal.append(obj_)
            obj_.original_tagname_ = 'signal'
        elif nodeName_ == 'signalReference':
            obj_ = signalReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signalReference.append(obj_)
            obj_.original_tagname_ = 'signalReference'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class signalsType


class signalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, id=None, name=None, dynamic=None, orientation=None, zOffset=None, country=None, type_=None, subtype=None, value=None, unit=None, height=None, width=None, text=None, hOffset=None, pitch=None, roll=None, validity=None, dependency=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dynamic = _cast(None, dynamic)
        self.dynamic_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.country = _cast(None, country)
        self.country_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.subtype = _cast(None, subtype)
        self.subtype_nsprefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signalType.subclass:
            return signalType.subclass(*args_, **kwargs_)
        else:
            return signalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_dependency(self):
        return self.dependency
    def set_dependency(self, dependency):
        self.dependency = dependency
    def add_dependency(self, value):
        self.dependency.append(value)
    def insert_dependency_at(self, index, value):
        self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value):
        self.dependency[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_dynamic(self):
        return self.dynamic
    def set_dynamic(self, dynamic):
        self.dynamic = dynamic
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_subtype(self):
        return self.subtype
    def set_subtype(self, subtype):
        self.subtype = subtype
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_hOffset(self):
        return self.hOffset
    def set_hOffset(self, hOffset):
        self.hOffset = hOffset
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_roll(self):
        return self.roll
    def set_roll(self, roll):
        self.roll = roll
    def validate_dynamic(self, value):
        # Validate type dynamic, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on dynamic' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_orientation(self, value):
        # Validate type orientation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_unit(self, value):
        # Validate type unit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['m', 'km', 'ft', 'mile', 'm/s', 'mph', 'km/h', 'kg', 't', '%']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on unit' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.validity or
            self.dependency or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='signalType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.dynamic is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            outfile.write(' dynamic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dynamic), input_name='dynamic')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.country), input_name='country')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.subtype is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            outfile.write(' subtype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subtype), input_name='subtype')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dependency', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dynamic', node)
        if value is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            self.dynamic = value
            self.validate_dynamic(self.dynamic)    # validate type dynamic
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_orientation(self.orientation)    # validate type orientation
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('subtype', node)
        if value is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            self.subtype = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            value = self.gds_parse_double(value, node, 'value')
            self.value = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_unit(self.unit)    # validate type unit
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            value = self.gds_parse_double(value, node, 'hOffset')
            self.hOffset = value
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            value = self.gds_parse_double(value, node, 'pitch')
            self.pitch = value
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            value = self.gds_parse_double(value, node, 'roll')
            self.roll = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dependency':
            obj_ = dependencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class signalType


class dependencyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dependencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dependencyType.subclass:
            return dependencyType.subclass(*args_, **kwargs_)
        else:
            return dependencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dependencyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dependencyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dependencyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dependencyType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dependencyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dependencyType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dependencyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class dependencyType


class signalReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, id=None, orientation=None, validity=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signalReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signalReferenceType.subclass:
            return signalReferenceType.subclass(*args_, **kwargs_)
        else:
            return signalReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def validate_orientation(self, value):
        # Validate type orientation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.validity or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signalReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signalReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signalReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signalReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signalReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='signalReferenceType'):
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signalReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_orientation(self.orientation)    # validate type orientation
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class signalReferenceType


class surfaceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CRG=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CRG is None:
            self.CRG = []
        else:
            self.CRG = CRG
        self.CRG_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, surfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if surfaceType.subclass:
            return surfaceType.subclass(*args_, **kwargs_)
        else:
            return surfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CRG(self):
        return self.CRG
    def set_CRG(self, CRG):
        self.CRG = CRG
    def add_CRG(self, value):
        self.CRG.append(value)
    def insert_CRG_at(self, index, value):
        self.CRG.insert(index, value)
    def replace_CRG_at(self, index, value):
        self.CRG[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.CRG or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='surfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('surfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'surfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='surfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='surfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='surfaceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='surfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CRG_ in self.CRG:
            namespaceprefix_ = self.CRG_nsprefix_ + ':' if (UseCapturedNS_ and self.CRG_nsprefix_) else ''
            CRG_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRG', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CRG':
            obj_ = CRGType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CRG.append(obj_)
            obj_.original_tagname_ = 'CRG'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class surfaceType


class CRGType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, file=None, sStart=None, sEnd=None, orientation=None, mode=None, purpose=None, sOffset=None, tOffset=None, zOffset=None, zScale=None, hOffset=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.mode = _cast(None, mode)
        self.mode_nsprefix_ = None
        self.purpose = _cast(None, purpose)
        self.purpose_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.zScale = _cast(float, zScale)
        self.zScale_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CRGType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CRGType.subclass:
            return CRGType.subclass(*args_, **kwargs_)
        else:
            return CRGType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def get_sStart(self):
        return self.sStart
    def set_sStart(self, sStart):
        self.sStart = sStart
    def get_sEnd(self):
        return self.sEnd
    def set_sEnd(self, sEnd):
        self.sEnd = sEnd
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_tOffset(self):
        return self.tOffset
    def set_tOffset(self, tOffset):
        self.tOffset = tOffset
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_zScale(self):
        return self.zScale
    def set_zScale(self, zScale):
        self.zScale = zScale
    def get_hOffset(self):
        return self.hOffset
    def set_hOffset(self, hOffset):
        self.hOffset = hOffset
    def validate_surfaceOrientation(self, value):
        # Validate type surfaceOrientation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['same', 'opposite']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on surfaceOrientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_mode(self, value):
        # Validate type mode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['attached', 'attached0', 'genuine']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on mode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_purpose(self, value):
        # Validate type purpose, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['elevation', 'friction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on purpose' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CRGType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CRGType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CRGType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CRGType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CRGType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CRGType'):
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.sStart is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
        if self.sEnd is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')), ))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.zScale is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            outfile.write(' zScale="%s"' % self.gds_format_double(self.zScale, input_name='zScale'))
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CRGType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            value = self.gds_parse_double(value, node, 'sStart')
            self.sStart = value
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            value = self.gds_parse_double(value, node, 'sEnd')
            self.sEnd = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_surfaceOrientation(self.orientation)    # validate type surfaceOrientation
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_mode(self.mode)    # validate type mode
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
            self.validate_purpose(self.purpose)    # validate type purpose
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            value = self.gds_parse_double(value, node, 'tOffset')
            self.tOffset = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        value = find_attr_value_('zScale', node)
        if value is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            value = self.gds_parse_double(value, node, 'zScale')
            self.zScale = value
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            value = self.gds_parse_double(value, node, 'hOffset')
            self.hOffset = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class CRGType


class railroadType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, switch=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if switch is None:
            self.switch = []
        else:
            self.switch = switch
        self.switch_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, railroadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if railroadType.subclass:
            return railroadType.subclass(*args_, **kwargs_)
        else:
            return railroadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_switch(self):
        return self.switch
    def set_switch(self, switch):
        self.switch = switch
    def add_switch(self, value):
        self.switch.append(value)
    def insert_switch_at(self, index, value):
        self.switch.insert(index, value)
    def replace_switch_at(self, index, value):
        self.switch[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.switch or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='railroadType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('railroadType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'railroadType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='railroadType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='railroadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='railroadType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='railroadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for switch_ in self.switch:
            namespaceprefix_ = self.switch_nsprefix_ + ':' if (UseCapturedNS_ and self.switch_nsprefix_) else ''
            switch_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='switch', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'switch':
            obj_ = switchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.switch.append(obj_)
            obj_.original_tagname_ = 'switch'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class railroadType


class switchType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, position=None, mainTrack=None, sideTrack=None, partner=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.position = _cast(None, position)
        self.position_nsprefix_ = None
        self.mainTrack = mainTrack
        self.mainTrack_nsprefix_ = None
        self.sideTrack = sideTrack
        self.sideTrack_nsprefix_ = None
        self.partner = partner
        self.partner_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, switchType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if switchType.subclass:
            return switchType.subclass(*args_, **kwargs_)
        else:
            return switchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mainTrack(self):
        return self.mainTrack
    def set_mainTrack(self, mainTrack):
        self.mainTrack = mainTrack
    def get_sideTrack(self):
        return self.sideTrack
    def set_sideTrack(self, sideTrack):
        self.sideTrack = sideTrack
    def get_partner(self):
        return self.partner
    def set_partner(self, partner):
        self.partner = partner
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def validate_position(self, value):
        # Validate type position, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['dynamic', 'straight', 'turn']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on position' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.mainTrack is not None or
            self.sideTrack is not None or
            self.partner is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='switchType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('switchType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'switchType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='switchType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='switchType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='switchType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='switchType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mainTrack is not None:
            namespaceprefix_ = self.mainTrack_nsprefix_ + ':' if (UseCapturedNS_ and self.mainTrack_nsprefix_) else ''
            self.mainTrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mainTrack', pretty_print=pretty_print)
        if self.sideTrack is not None:
            namespaceprefix_ = self.sideTrack_nsprefix_ + ':' if (UseCapturedNS_ and self.sideTrack_nsprefix_) else ''
            self.sideTrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sideTrack', pretty_print=pretty_print)
        if self.partner is not None:
            namespaceprefix_ = self.partner_nsprefix_ + ':' if (UseCapturedNS_ and self.partner_nsprefix_) else ''
            self.partner.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partner', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
            self.validate_position(self.position)    # validate type position
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainTrack':
            obj_ = mainTrackType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainTrack = obj_
            obj_.original_tagname_ = 'mainTrack'
        elif nodeName_ == 'sideTrack':
            obj_ = sideTrackType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sideTrack = obj_
            obj_.original_tagname_ = 'sideTrack'
        elif nodeName_ == 'partner':
            obj_ = partnerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partner = obj_
            obj_.original_tagname_ = 'partner'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class switchType


class mainTrackType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, s=None, dir=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mainTrackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mainTrackType.subclass:
            return mainTrackType.subclass(*args_, **kwargs_)
        else:
            return mainTrackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def validate_dir(self, value):
        # Validate type dir, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on dir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mainTrackType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mainTrackType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mainTrackType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mainTrackType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mainTrackType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mainTrackType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mainTrackType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.validate_dir(self.dir)    # validate type dir
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class mainTrackType


class sideTrackType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, s=None, dir=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sideTrackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sideTrackType.subclass:
            return sideTrackType.subclass(*args_, **kwargs_)
        else:
            return sideTrackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def validate_dir(self, value):
        # Validate type dir, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on dir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sideTrackType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sideTrackType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sideTrackType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sideTrackType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sideTrackType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sideTrackType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sideTrackType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.validate_dir(self.dir)    # validate type dir
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class sideTrackType


class partnerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, partnerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if partnerType.subclass:
            return partnerType.subclass(*args_, **kwargs_)
        else:
            return partnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='partnerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('partnerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'partnerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='partnerType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='partnerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='partnerType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='partnerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class partnerType


class controllerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, sequence=None, control=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controllerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controllerType.subclass:
            return controllerType.subclass(*args_, **kwargs_)
        else:
            return controllerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def _hasContent(self):
        if (
            self.control or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controllerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controllerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'controllerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controllerType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controllerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controllerType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controllerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = controlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class controllerType


class controlType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, signalId=None, type_=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.signalId = _cast(None, signalId)
        self.signalId_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controlType.subclass:
            return controlType.subclass(*args_, **kwargs_)
        else:
            return controlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_signalId(self):
        return self.signalId
    def set_signalId(self, signalId):
        self.signalId = signalId
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'controlType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controlType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controlType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controlType'):
        if self.signalId is not None and 'signalId' not in already_processed:
            already_processed.add('signalId')
            outfile.write(' signalId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.signalId), input_name='signalId')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('signalId', node)
        if value is not None and 'signalId' not in already_processed:
            already_processed.add('signalId')
            self.signalId = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class controlType


class junctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, connection=None, priority=None, controller=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if connection is None:
            self.connection = []
        else:
            self.connection = connection
        self.connection_nsprefix_ = None
        if priority is None:
            self.priority = []
        else:
            self.priority = priority
        self.priority_nsprefix_ = None
        if controller is None:
            self.controller = []
        else:
            self.controller = controller
        self.controller_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, junctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if junctionType.subclass:
            return junctionType.subclass(*args_, **kwargs_)
        else:
            return junctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_connection(self):
        return self.connection
    def set_connection(self, connection):
        self.connection = connection
    def add_connection(self, value):
        self.connection.append(value)
    def insert_connection_at(self, index, value):
        self.connection.insert(index, value)
    def replace_connection_at(self, index, value):
        self.connection[index] = value
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    def add_priority(self, value):
        self.priority.append(value)
    def insert_priority_at(self, index, value):
        self.priority.insert(index, value)
    def replace_priority_at(self, index, value):
        self.priority[index] = value
    def get_controller(self):
        return self.controller
    def set_controller(self, controller):
        self.controller = controller
    def add_controller(self, value):
        self.controller.append(value)
    def insert_controller_at(self, index, value):
        self.controller.insert(index, value)
    def replace_controller_at(self, index, value):
        self.controller[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.connection or
            self.priority or
            self.controller or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='junctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('junctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'junctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='junctionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='junctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='junctionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='junctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for connection_ in self.connection:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            connection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
        for priority_ in self.priority:
            namespaceprefix_ = self.priority_nsprefix_ + ':' if (UseCapturedNS_ and self.priority_nsprefix_) else ''
            priority_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priority', pretty_print=pretty_print)
        for controller_ in self.controller:
            namespaceprefix_ = self.controller_nsprefix_ + ':' if (UseCapturedNS_ and self.controller_nsprefix_) else ''
            controller_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controller', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'connection':
            obj_ = connectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection.append(obj_)
            obj_.original_tagname_ = 'connection'
        elif nodeName_ == 'priority':
            obj_ = priorityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priority.append(obj_)
            obj_.original_tagname_ = 'priority'
        elif nodeName_ == 'controller':
            obj_ = controllerType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controller.append(obj_)
            obj_.original_tagname_ = 'controller'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class junctionType


class connectionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, incomingRoad=None, connectingRoad=None, contactPoint=None, laneLink=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.incomingRoad = _cast(None, incomingRoad)
        self.incomingRoad_nsprefix_ = None
        self.connectingRoad = _cast(None, connectingRoad)
        self.connectingRoad_nsprefix_ = None
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
        if laneLink is None:
            self.laneLink = []
        else:
            self.laneLink = laneLink
        self.laneLink_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, connectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if connectionType.subclass:
            return connectionType.subclass(*args_, **kwargs_)
        else:
            return connectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_laneLink(self):
        return self.laneLink
    def set_laneLink(self, laneLink):
        self.laneLink = laneLink
    def add_laneLink(self, value):
        self.laneLink.append(value)
    def insert_laneLink_at(self, index, value):
        self.laneLink.insert(index, value)
    def replace_laneLink_at(self, index, value):
        self.laneLink[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_incomingRoad(self):
        return self.incomingRoad
    def set_incomingRoad(self, incomingRoad):
        self.incomingRoad = incomingRoad
    def get_connectingRoad(self):
        return self.connectingRoad
    def set_connectingRoad(self, connectingRoad):
        self.connectingRoad = connectingRoad
    def get_contactPoint(self):
        return self.contactPoint
    def set_contactPoint(self, contactPoint):
        self.contactPoint = contactPoint
    def validate_contactPoint(self, value):
        # Validate type contactPoint, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on contactPoint' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.laneLink or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='connectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('connectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'connectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='connectionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='connectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='connectionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.incomingRoad is not None and 'incomingRoad' not in already_processed:
            already_processed.add('incomingRoad')
            outfile.write(' incomingRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.incomingRoad), input_name='incomingRoad')), ))
        if self.connectingRoad is not None and 'connectingRoad' not in already_processed:
            already_processed.add('connectingRoad')
            outfile.write(' connectingRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectingRoad), input_name='connectingRoad')), ))
        if self.contactPoint is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='connectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for laneLink_ in self.laneLink:
            namespaceprefix_ = self.laneLink_nsprefix_ + ':' if (UseCapturedNS_ and self.laneLink_nsprefix_) else ''
            laneLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneLink', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('incomingRoad', node)
        if value is not None and 'incomingRoad' not in already_processed:
            already_processed.add('incomingRoad')
            self.incomingRoad = value
        value = find_attr_value_('connectingRoad', node)
        if value is not None and 'connectingRoad' not in already_processed:
            already_processed.add('connectingRoad')
            self.connectingRoad = value
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_contactPoint(self.contactPoint)    # validate type contactPoint
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'laneLink':
            obj_ = laneLinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laneLink.append(obj_)
            obj_.original_tagname_ = 'laneLink'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class connectionType


class laneLinkType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = _cast(int, from_)
        self.from__nsprefix_ = None
        self.to = _cast(int, to)
        self.to_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, laneLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if laneLinkType.subclass:
            return laneLinkType.subclass(*args_, **kwargs_)
        else:
            return laneLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneLinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('laneLinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'laneLinkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='laneLinkType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='laneLinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='laneLinkType'):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from="%s"' % self.gds_format_integer(self.from_, input_name='from'))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to="%s"' % self.gds_format_integer(self.to, input_name='to'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='laneLinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = self.gds_parse_integer(value, node, 'from')
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = self.gds_parse_integer(value, node, 'to')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class laneLinkType


class priorityType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, high=None, low=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.high = _cast(None, high)
        self.high_nsprefix_ = None
        self.low = _cast(None, low)
        self.low_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, priorityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if priorityType.subclass:
            return priorityType.subclass(*args_, **kwargs_)
        else:
            return priorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='priorityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('priorityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'priorityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='priorityType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='priorityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='priorityType'):
        if self.high is not None and 'high' not in already_processed:
            already_processed.add('high')
            outfile.write(' high=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.high), input_name='high')), ))
        if self.low is not None and 'low' not in already_processed:
            already_processed.add('low')
            outfile.write(' low=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.low), input_name='low')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='priorityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('high', node)
        if value is not None and 'high' not in already_processed:
            already_processed.add('high')
            self.high = value
        value = find_attr_value_('low', node)
        if value is not None and 'low' not in already_processed:
            already_processed.add('low')
            self.low = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class priorityType


class controllerType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, sequence=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controllerType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controllerType4.subclass:
            return controllerType4.subclass(*args_, **kwargs_)
        else:
            return controllerType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controllerType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controllerType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'controllerType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controllerType4')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controllerType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controllerType4'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controllerType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class controllerType4


class junctionGroupType5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, type_=None, junctionReference=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if junctionReference is None:
            self.junctionReference = []
        else:
            self.junctionReference = junctionReference
        self.junctionReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, junctionGroupType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if junctionGroupType5.subclass:
            return junctionGroupType5.subclass(*args_, **kwargs_)
        else:
            return junctionGroupType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_junctionReference(self):
        return self.junctionReference
    def set_junctionReference(self, junctionReference):
        self.junctionReference = junctionReference
    def add_junctionReference(self, value):
        self.junctionReference.append(value)
    def insert_junctionReference_at(self, index, value):
        self.junctionReference.insert(index, value)
    def replace_junctionReference_at(self, index, value):
        self.junctionReference[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_junctionGroupType(self, value):
        # Validate type junctionGroupType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['roundabout', 'unknown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on junctionGroupType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.junctionReference or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='junctionGroupType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('junctionGroupType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'junctionGroupType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='junctionGroupType5')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='junctionGroupType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='junctionGroupType5'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='junctionGroupType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for junctionReference_ in self.junctionReference:
            namespaceprefix_ = self.junctionReference_nsprefix_ + ':' if (UseCapturedNS_ and self.junctionReference_nsprefix_) else ''
            junctionReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junctionReference', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_junctionGroupType(self.type_)    # validate type junctionGroupType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'junctionReference':
            obj_ = junctionReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.junctionReference.append(obj_)
            obj_.original_tagname_ = 'junctionReference'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class junctionGroupType5


class junctionReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, junction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.junction = _cast(None, junction)
        self.junction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, junctionReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if junctionReferenceType.subclass:
            return junctionReferenceType.subclass(*args_, **kwargs_)
        else:
            return junctionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='junctionReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('junctionReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'junctionReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='junctionReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='junctionReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='junctionReferenceType'):
        if self.junction is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            outfile.write(' junction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.junction), input_name='junction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='junctionReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('junction', node)
        if value is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            self.junction = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class junctionReferenceType


class stationType6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, type_=None, platform=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stationType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stationType6.subclass:
            return stationType6.subclass(*args_, **kwargs_)
        else:
            return stationType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_stationType(self, value):
        # Validate type stationType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['small', 'medium', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on stationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.platform or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stationType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stationType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'stationType6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stationType6')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stationType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stationType6'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stationType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_stationType(self.type_)    # validate type stationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'platform':
            obj_ = platformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class stationType6


class platformType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.segment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, platformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if platformType.subclass:
            return platformType.subclass(*args_, **kwargs_)
        else:
            return platformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_segment(self):
        return self.segment
    def set_segment(self, segment):
        self.segment = segment
    def add_segment(self, value):
        self.segment.append(value)
    def insert_segment_at(self, index, value):
        self.segment.insert(index, value)
    def replace_segment_at(self, index, value):
        self.segment[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='platformType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('platformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'platformType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='platformType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='platformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='platformType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='platformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            namespaceprefix_ = self.segment_nsprefix_ + ':' if (UseCapturedNS_ and self.segment_nsprefix_) else ''
            segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'segment':
            obj_ = segmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
# end class platformType


class segmentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, roadId=None, sStart=None, sEnd=None, side=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.roadId = _cast(None, roadId)
        self.roadId_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segmentType.subclass:
            return segmentType.subclass(*args_, **kwargs_)
        else:
            return segmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_roadId(self):
        return self.roadId
    def set_roadId(self, roadId):
        self.roadId = roadId
    def get_sStart(self):
        return self.sStart
    def set_sStart(self, sStart):
        self.sStart = sStart
    def get_sEnd(self):
        return self.sEnd
    def set_sEnd(self, sEnd):
        self.sEnd = sEnd
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def validate_side(self, value):
        # Validate type side, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on side' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='segmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'segmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='segmentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='segmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='segmentType'):
        if self.roadId is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            outfile.write(' roadId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.roadId), input_name='roadId')), ))
        if self.sStart is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
        if self.sEnd is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if self.side is not None and 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='segmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roadId', node)
        if value is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            self.roadId = value
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            value = self.gds_parse_double(value, node, 'sStart')
            self.sStart = value
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            value = self.gds_parse_double(value, node, 'sEnd')
            self.sEnd = value
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_side(self.side)    # validate type side
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class segmentType


class markingType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, side=None, type_=None, width=None, color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, markingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if markingType.subclass:
            return markingType.subclass(*args_, **kwargs_)
        else:
            return markingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def validate_parkingSpacemarkingSide(self, value):
        # Validate type parkingSpacemarkingSide, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['front', 'rear', 'left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on parkingSpacemarkingSide' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_roadmarkType(self, value):
        # Validate type roadmarkType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'solid', 'broken', 'solid solid', 'solid broken', 'broken solid', 'broken broken', 'botts dots', 'grass', 'curb']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roadmarkType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on color' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='markingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('markingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'markingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='markingType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='markingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='markingType'):
        if self.side is not None and 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='markingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_parkingSpacemarkingSide(self.side)    # validate type parkingSpacemarkingSide
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_roadmarkType(self.type_)    # validate type roadmarkType
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class markingType


class linkType7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, predecessor=None, successor=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkType7.subclass:
            return linkType7.subclass(*args_, **kwargs_)
        else:
            return linkType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predecessor(self):
        return self.predecessor
    def set_predecessor(self, predecessor):
        self.predecessor = predecessor
    def get_successor(self):
        return self.successor
    def set_successor(self, successor):
        self.successor = successor
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'linkType7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkType7')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='linkType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='linkType7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predecessor':
            obj_ = predecessorType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = successorType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class linkType7


class predecessorType8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, predecessorType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if predecessorType8.subclass:
            return predecessorType8.subclass(*args_, **kwargs_)
        else:
            return predecessorType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='predecessorType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('predecessorType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'predecessorType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='predecessorType8')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='predecessorType8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='predecessorType8'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='predecessorType8', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class predecessorType8


class successorType9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, successorType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if successorType9.subclass:
            return successorType9.subclass(*args_, **kwargs_)
        else:
            return successorType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='successorType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('successorType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'successorType9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='successorType9')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='successorType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='successorType9'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='successorType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class successorType9


class widthType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, widthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if widthType.subclass:
            return widthType.subclass(*args_, **kwargs_)
        else:
            return widthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='widthType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('widthType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'widthType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='widthType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='widthType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='widthType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='widthType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class widthType


class borderType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, a=None, b=None, c=None, d=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, borderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if borderType.subclass:
            return borderType.subclass(*args_, **kwargs_)
        else:
            return borderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='borderType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('borderType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'borderType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='borderType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='borderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='borderType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='borderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class borderType


class roadMarkType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, type__attr=None, weight=None, color=None, material=None, width=None, laneChange=None, height=None, type_=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.type__attr = _cast(None, type__attr)
        self.type__attr_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.material = _cast(None, material)
        self.material_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.laneChange = _cast(None, laneChange)
        self.laneChange_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, roadMarkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if roadMarkType.subclass:
            return roadMarkType.subclass(*args_, **kwargs_)
        else:
            return roadMarkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_type__attr(self):
        return self.type__attr
    def set_type__attr(self, type__attr):
        self.type__attr = type__attr
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_laneChange(self):
        return self.laneChange
    def set_laneChange(self, laneChange):
        self.laneChange = laneChange
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def validate_roadmarkType(self, value):
        # Validate type roadmarkType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'solid', 'broken', 'solid solid', 'solid broken', 'broken solid', 'broken broken', 'botts dots', 'grass', 'curb']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roadmarkType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_weight(self, value):
        # Validate type weight, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on color' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_laneChange(self, value):
        # Validate type laneChange, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['increase', 'decrease', 'both', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on laneChange' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.type_ is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roadMarkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('roadMarkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'roadMarkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roadMarkType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='roadMarkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='roadMarkType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.type__attr is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type__attr), input_name='type__attr')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weight), input_name='weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.material is not None and 'material' not in already_processed:
            already_processed.add('material')
            outfile.write(' material=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.material), input_name='material')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.laneChange is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            outfile.write(' laneChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.laneChange), input_name='laneChange')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roadMarkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('type', node)
        if value is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            self.type__attr = value
            self.validate_roadmarkType(self.type__attr)    # validate type roadmarkType
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_weight(self.weight)    # validate type weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('material', node)
        if value is not None and 'material' not in already_processed:
            already_processed.add('material')
            self.material = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
        value = find_attr_value_('laneChange', node)
        if value is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            self.laneChange = value
            self.validate_laneChange(self.laneChange)    # validate type laneChange
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'type':
            obj_ = typeType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class roadMarkType


class typeType10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, width=None, line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeType10.subclass:
            return typeType10.subclass(*args_, **kwargs_)
        else:
            return typeType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def _hasContent(self):
        if (
            self.line
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeType10')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeType10'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line':
            obj_ = lineType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
# end class typeType10


class lineType11(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, length=None, space=None, tOffset=None, sOffset=None, rule=None, width=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.space = _cast(float, space)
        self.space_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lineType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lineType11.subclass:
            return lineType11.subclass(*args_, **kwargs_)
        else:
            return lineType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_tOffset(self):
        return self.tOffset
    def set_tOffset(self, tOffset):
        self.tOffset = tOffset
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def validate_rule(self, value):
        # Validate type rule, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['no passing', 'caution', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lineType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lineType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lineType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lineType11')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lineType11', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lineType11'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space="%s"' % self.gds_format_double(self.space, input_name='space'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lineType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            value = self.gds_parse_double(value, node, 'space')
            self.space = value
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            value = self.gds_parse_double(value, node, 'tOffset')
            self.tOffset = value
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_rule(self.rule)    # validate type rule
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class lineType11


class materialType12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, surface=None, friction=None, roughness=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
        self.friction = _cast(float, friction)
        self.friction_nsprefix_ = None
        self.roughness = _cast(float, roughness)
        self.roughness_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, materialType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if materialType12.subclass:
            return materialType12.subclass(*args_, **kwargs_)
        else:
            return materialType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_friction(self):
        return self.friction
    def set_friction(self, friction):
        self.friction = friction
    def get_roughness(self):
        return self.roughness
    def set_roughness(self, roughness):
        self.roughness = roughness
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='materialType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('materialType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'materialType12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='materialType12')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='materialType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='materialType12'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
        if self.roughness is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            outfile.write(' roughness="%s"' % self.gds_format_double(self.roughness, input_name='roughness'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='materialType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            value = self.gds_parse_double(value, node, 'friction')
            self.friction = value
        value = find_attr_value_('roughness', node)
        if value is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            value = self.gds_parse_double(value, node, 'roughness')
            self.roughness = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class materialType12


class visibilityType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, forward=None, back=None, left=None, right=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.forward = _cast(float, forward)
        self.forward_nsprefix_ = None
        self.back = _cast(float, back)
        self.back_nsprefix_ = None
        self.left = _cast(float, left)
        self.left_nsprefix_ = None
        self.right = _cast(float, right)
        self.right_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, visibilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if visibilityType.subclass:
            return visibilityType.subclass(*args_, **kwargs_)
        else:
            return visibilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_forward(self):
        return self.forward
    def set_forward(self, forward):
        self.forward = forward
    def get_back(self):
        return self.back
    def set_back(self, back):
        self.back = back
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='visibilityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('visibilityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'visibilityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='visibilityType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='visibilityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='visibilityType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.forward is not None and 'forward' not in already_processed:
            already_processed.add('forward')
            outfile.write(' forward="%s"' % self.gds_format_double(self.forward, input_name='forward'))
        if self.back is not None and 'back' not in already_processed:
            already_processed.add('back')
            outfile.write(' back="%s"' % self.gds_format_double(self.back, input_name='back'))
        if self.left is not None and 'left' not in already_processed:
            already_processed.add('left')
            outfile.write(' left="%s"' % self.gds_format_double(self.left, input_name='left'))
        if self.right is not None and 'right' not in already_processed:
            already_processed.add('right')
            outfile.write(' right="%s"' % self.gds_format_double(self.right, input_name='right'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='visibilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('forward', node)
        if value is not None and 'forward' not in already_processed:
            already_processed.add('forward')
            value = self.gds_parse_double(value, node, 'forward')
            self.forward = value
        value = find_attr_value_('back', node)
        if value is not None and 'back' not in already_processed:
            already_processed.add('back')
            value = self.gds_parse_double(value, node, 'back')
            self.back = value
        value = find_attr_value_('left', node)
        if value is not None and 'left' not in already_processed:
            already_processed.add('left')
            value = self.gds_parse_double(value, node, 'left')
            self.left = value
        value = find_attr_value_('right', node)
        if value is not None and 'right' not in already_processed:
            already_processed.add('right')
            value = self.gds_parse_double(value, node, 'right')
            self.right = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class visibilityType


class speedType13(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, max=None, unit=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.max = _cast(float, max)
        self.max_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, speedType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if speedType13.subclass:
            return speedType13.subclass(*args_, **kwargs_)
        else:
            return speedType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def validate_unit(self, value):
        # Validate type unit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['m', 'km', 'ft', 'mile', 'm/s', 'mph', 'km/h', 'kg', 't', '%']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on unit' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='speedType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('speedType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'speedType13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='speedType13')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='speedType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='speedType13'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_double(self.max, input_name='max'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='speedType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            value = self.gds_parse_double(value, node, 'max')
            self.max = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_unit(self.unit)    # validate type unit
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class speedType13


class accessType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, restriction=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.restriction = _cast(None, restriction)
        self.restriction_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessType.subclass:
            return accessType.subclass(*args_, **kwargs_)
        else:
            return accessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_restriction(self):
        return self.restriction
    def set_restriction(self, restriction):
        self.restriction = restriction
    def validate_restriction(self, value):
        # Validate type restriction, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simulator', 'autonomous traffic', 'pedestrian', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on restriction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accessType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.add('restriction')
            outfile.write(' restriction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restriction), input_name='restriction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.add('restriction')
            self.restriction = value
            self.validate_restriction(self.restriction)    # validate type restriction
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class accessType


class heightType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, inner=None, outer=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.inner = _cast(float, inner)
        self.inner_nsprefix_ = None
        self.outer = _cast(float, outer)
        self.outer_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, heightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if heightType.subclass:
            return heightType.subclass(*args_, **kwargs_)
        else:
            return heightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_inner(self):
        return self.inner
    def set_inner(self, inner):
        self.inner = inner
    def get_outer(self):
        return self.outer
    def set_outer(self, outer):
        self.outer = outer
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='heightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('heightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'heightType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='heightType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='heightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='heightType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.inner is not None and 'inner' not in already_processed:
            already_processed.add('inner')
            outfile.write(' inner="%s"' % self.gds_format_double(self.inner, input_name='inner'))
        if self.outer is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            outfile.write(' outer="%s"' % self.gds_format_double(self.outer, input_name='outer'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='heightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('inner', node)
        if value is not None and 'inner' not in already_processed:
            already_processed.add('inner')
            value = self.gds_parse_double(value, node, 'inner')
            self.inner = value
        value = find_attr_value_('outer', node)
        if value is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            value = self.gds_parse_double(value, node, 'outer')
            self.outer = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class heightType


class ruleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, value=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ruleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ruleType.subclass:
            return ruleType.subclass(*args_, **kwargs_)
        else:
            return ruleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def _hasContent(self):
        if (
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ruleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ruleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ruleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ruleType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ruleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ruleType'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ruleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class ruleType


class linkType14(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, predecessor=None, successor=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkType14.subclass:
            return linkType14.subclass(*args_, **kwargs_)
        else:
            return linkType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predecessor(self):
        return self.predecessor
    def set_predecessor(self, predecessor):
        self.predecessor = predecessor
    def get_successor(self):
        return self.successor
    def set_successor(self, successor):
        self.successor = successor
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def _hasContent(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'linkType14':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkType14')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='linkType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='linkType14'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predecessor':
            obj_ = predecessorType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = successorType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class linkType14


class predecessorType15(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, predecessorType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if predecessorType15.subclass:
            return predecessorType15.subclass(*args_, **kwargs_)
        else:
            return predecessorType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='predecessorType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('predecessorType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'predecessorType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='predecessorType15')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='predecessorType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='predecessorType15'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='predecessorType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class predecessorType15


class successorType16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, successorType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if successorType16.subclass:
            return successorType16.subclass(*args_, **kwargs_)
        else:
            return successorType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='successorType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('successorType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'successorType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='successorType16')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='successorType16', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='successorType16'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='successorType16', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class successorType16


class roadMarkType17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, type__attr=None, weight=None, color=None, material=None, width=None, laneChange=None, height=None, type_=None, userData=None, include=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.type__attr = _cast(None, type__attr)
        self.type__attr_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.material = _cast(None, material)
        self.material_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.laneChange = _cast(None, laneChange)
        self.laneChange_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, roadMarkType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if roadMarkType17.subclass:
            return roadMarkType17.subclass(*args_, **kwargs_)
        else:
            return roadMarkType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_type__attr(self):
        return self.type__attr
    def set_type__attr(self, type__attr):
        self.type__attr = type__attr
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_laneChange(self):
        return self.laneChange
    def set_laneChange(self, laneChange):
        self.laneChange = laneChange
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def validate_roadmarkType(self, value):
        # Validate type roadmarkType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'solid', 'broken', 'solid solid', 'solid broken', 'broken solid', 'broken broken', 'botts dots', 'grass', 'curb']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roadmarkType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_weight(self, value):
        # Validate type weight, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on color' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_laneChange(self, value):
        # Validate type laneChange, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['increase', 'decrease', 'both', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on laneChange' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.type_ is not None or
            self.userData or
            self.include
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roadMarkType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('roadMarkType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'roadMarkType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roadMarkType17')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='roadMarkType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='roadMarkType17'):
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.type__attr is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type__attr), input_name='type__attr')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weight), input_name='weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.material is not None and 'material' not in already_processed:
            already_processed.add('material')
            outfile.write(' material=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.material), input_name='material')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.laneChange is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            outfile.write(' laneChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.laneChange), input_name='laneChange')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roadMarkType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('type', node)
        if value is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            self.type__attr = value
            self.validate_roadmarkType(self.type__attr)    # validate type roadmarkType
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_weight(self.weight)    # validate type weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('material', node)
        if value is not None and 'material' not in already_processed:
            already_processed.add('material')
            self.material = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
        value = find_attr_value_('laneChange', node)
        if value is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            self.laneChange = value
            self.validate_laneChange(self.laneChange)    # validate type laneChange
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'type':
            obj_ = typeType18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'userData':
            obj_ = userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
# end class roadMarkType17


class typeType18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, width=None, line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeType18.subclass:
            return typeType18.subclass(*args_, **kwargs_)
        else:
            return typeType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def _hasContent(self):
        if (
            self.line
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeType18')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeType18'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line':
            obj_ = lineType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
# end class typeType18


class lineType19(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, length=None, space=None, tOffset=None, sOffset=None, rule=None, width=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.space = _cast(float, space)
        self.space_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lineType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lineType19.subclass:
            return lineType19.subclass(*args_, **kwargs_)
        else:
            return lineType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_tOffset(self):
        return self.tOffset
    def set_tOffset(self, tOffset):
        self.tOffset = tOffset
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def validate_rule(self, value):
        # Validate type rule, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['no passing', 'caution', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lineType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lineType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lineType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lineType19')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lineType19', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lineType19'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space="%s"' % self.gds_format_double(self.space, input_name='space'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lineType19', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            value = self.gds_parse_double(value, node, 'space')
            self.space = value
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            value = self.gds_parse_double(value, node, 'tOffset')
            self.tOffset = value
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_rule(self.rule)    # validate type rule
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class lineType19


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from opendrive_parser_14H import *\n\n')
        sys.stdout.write('import opendrive_parser_14H as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {}

__all__ = [
    "CRGType",
    "OpenDRIVE",
    "accessType",
    "arcType",
    "borderType",
    "bridgeType3",
    "centerLane",
    "centerType",
    "connectionType",
    "controlType",
    "controllerType",
    "controllerType4",
    "cornerLocalType",
    "cornerRoadType",
    "crossfallType",
    "dependencyType",
    "elevationProfileType",
    "elevationType",
    "geometryType",
    "headerType",
    "heightType",
    "include",
    "junctionGroupType5",
    "junctionReferenceType",
    "junctionType",
    "lane",
    "laneLinkType",
    "laneOffsetType",
    "laneSectionType",
    "laneValidity",
    "lanesType",
    "lateralProfileType",
    "leftType",
    "lineType",
    "lineType11",
    "lineType19",
    "linkType",
    "linkType14",
    "linkType7",
    "mainTrackType",
    "markingType",
    "materialType",
    "materialType12",
    "neighborType",
    "objectReferenceType",
    "objectType",
    "objectsType",
    "outlineType",
    "paramPoly3Type",
    "parkingSpace",
    "partnerType",
    "planViewType",
    "platformType",
    "poly3Type",
    "predecessorType",
    "predecessorType15",
    "predecessorType8",
    "priorityType",
    "railroadType",
    "repeatType",
    "rightType",
    "roadMarkType",
    "roadMarkType17",
    "roadType1",
    "ruleType",
    "segmentType",
    "shapeType",
    "sideTrackType",
    "signalReferenceType",
    "signalType",
    "signalsType",
    "speedType",
    "speedType13",
    "spiralType",
    "stationType6",
    "successorType",
    "successorType16",
    "successorType9",
    "superelevationType",
    "surfaceType",
    "switchType",
    "tunnelType2",
    "typeType",
    "typeType10",
    "typeType18",
    "userData",
    "visibilityType",
    "widthType"
]
